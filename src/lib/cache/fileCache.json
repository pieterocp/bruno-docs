{
  "_app.tsx": {
    "name": "_app.tsx",
    "content": "import \"@/app/globals.css\";\nimport { useConfig } from \"nextra-theme-docs\";\nimport { Toaster } from \"@/components/ui/sonner\";\nimport { ThemeProvider } from \"@/components/theme-provider\";\nimport GoogleAnalytics from \"@/components/google-analytics\";\nimport type { AppProps } from 'next/app';\nimport { ReleaseBanner } from \"@/components/ui/release-banner\";\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    \n      \n      \n        \n        \n        \n      \n    \n  );\n} ",
    "parentName": null,
    "path": "_app.tsx"
  },
  "advanced-guides/visualize": {
    "name": "visualize",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nResponse Visualization\n\n\nThe `bru.visualize` function in the Bruno CLI allows for rendering various types of visualizations such as tables and HTML. It supports different providers for each visualization type, offering flexibility in how data is displayed. Below are examples and details on the supported types and providers.\n\n```javascript\nbru.visualize(type, config)\n```\n\n1. **type**: The type of visualization to render (e.g., 'table', 'html').\n\n2. **config**: A configuration object that includes:\n\n    - **name**: The name of the visualization instance.\n\n    - **provider**: The rendering library or provider used to display the visualization (e.g., 'ag-grid', 'react-table').\n\n    - **props**: Additional properties required by the provider to configure the visualization.\n\nSupported Visualization Types and Providers\n\n\nTable Visualization ('table')\n\n\nYou can render tables using different providers like `ag-grid` and `react-table`.\n\nUsing **ag-grid**\n\n\n*Example:*\n\n![ag-grid](/screenshots/visualization/ag-grid.png)\n\n```javascript\nconst rowData = [\n  { name: 'John Doe', age: 28, email: 'john@example.com', city: 'New York' },\n  { name: 'Jane Smith', age: 32, email: 'jane@example.com', city: 'London' }\n];\n\nconst columnDefinitions = [\n  { field: \"name\", filter: true, floatingFilter: true },\n  { field: \"age\", filter: true, floatingFilter: true },\n  { field: \"email\", filter: true, floatingFilter: true },\n  { field: \"city\", filter: true, floatingFilter: true }\n];\n\nbru.visualize('table', {\n  name: 'table1',\n  provider: 'ag-grid',\n  props: { rowData, columnDefinitions }\n});\n```\n\nThis will render a table using the ag-grid provider with filters enabled on all columns.\n\nUsing **react-table**\n\n\n*Example:*\n\n![react-table](/screenshots/visualization/react-table.png)\n\n```javascript\nconst rowData1 = Array.from({ length: 2500 })\n  .map((_) => [\n    { firstName: 'Tanner', lastName: 'Linsley', age: 24, visits: 100 },\n    { firstName: 'Tandy', lastName: 'Miller', age: 40, visits: 40 },\n    { firstName: 'Joe', lastName: 'Dirte', age: 45, visits: 20 },\n  ]).flat();\n\n\nconst columnDefinitions1 = [\n  {\n    id: \"firstName\",\n    cell: (info) => info.getValue(),\n    header: () => `First Name`,\n    meta: { filterVariant: \"text\" },\n  },\n  {\n    id: \"lastName\",\n    cell: (info) => info.getValue(),\n    header: () => `Last Name`,\n    meta: { filterVariant: \"text\" },\n  },\n  // Additional column definitions here...\n];\n\nbru.visualize('table', {\n  name: 'table2',\n  provider: 'react-table',\n  props: { rowData: rowData1, columnDefinitions: columnDefinitions1 }\n});\n```\n\nThis example renders a large table using the react-table provider, with custom headers and filter variants.\n\nHTML Visualization ('html')\n\n\nYou can also render custom HTML content using the html type. This allows for advanced templating and formatting, such as generating a data table or a report.\n\nUsing **HTML** String\n\n\n*Example:*\n\n![html](/screenshots/visualization/html.png)\n\n```javascript\nconst htmlString = `\n\n  \n    \n      table { width: 100%; border-collapse: collapse; }\n      th, td { border: 1px solid black; padding: 8px; }\n      th { background-color: #f2f2f2; }\n    \n  \n  \n    \n      NameAgeEmailCity\n      John Doe28john@example.comNew York\n      Jane Smith32jane@example.comLondon\n    \n  \n\n`;\n\nbru.visualize('html', {\n  name: 'htmlReport',\n  content: htmlString\n});\n```\n\nThis example will render an HTML table with predefined data using the html type.\n\nParameters\n\n\n| Name     | Type     | Description                                                                                     |\n|----------|----------|-------------------------------------------------------------------------------------------------|\n| `type`   | `string` | The type of visualization to render. Supported values: `'table'`, `'html'`.                     |\n| `config` | `object` | Configuration object for the visualization. See below for available properties.                 |\n\nConfig Properties\n\n\n| Property   | Type     | Description                                                                                     |\n|------------|----------|-------------------------------------------------------------------------------------------------|\n| `name`     | `string` | Name of the visualization instance.                                                             |\n| `provider` | `string` | The provider or rendering engine to use for the visualization. E.g., `'ag-grid'`, `'react-table'`. |\n| `props`    | `object` | Additional properties required by the provider to configure the visualization.                  |\n| `content`  | `string` | (For `html` type only) The HTML content to render.                                             |\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/visualize"
  },
  "advanced-guides/working-with-bigint": {
    "name": "working-with-bigint",
    "content": "Working with BigInt\n\n\nWhen your response data contains `BigInt`, the parsed value may become corrupted because Bruno parses the response data by default, which can lead to a loss of fidelity.\nThis occurs because `JSON.parse()` does not handle `BigInt` values correctly by default.\n\nHowever, if you need access to the raw response data (for example, if it contains `BigInt`), you can bypass the parsing step.\n\nTo prevent automatic parsing and work directly with the raw response data, add the below expression to the `pre-request` script.\n\n```js\nreq.disableParsingResponseJson();\n```\n",
    "parentName": "advanced-guides",
    "path": "advanced-guides/working-with-bigint"
  },
  "api-docs/collection-docs": {
    "name": "collection-docs",
    "content": "Document a collection\n\n\nBruno allows you to add documentation directly at the collection level, which can be extremely useful for providing a high-level overview of your entire API collection.\n\nBy configuring documentation at the collection level, you ensure that users and developers have a centralized place to understand the key concepts, actions, and flow of your API before diving into individual requests or folders.\n\nCreate collection docs\n\n\n1. Go to the **Collection** and click on **More Options**.\n2. Select **Settings** from the dropdown menu.\n\n![collection-settings](/screenshots/send-request/collection-settings-docs.webp)\n\n3. Navigate to the **Docs** tab.\n4. Click the **Edit** button to add your collection-level documentation.\n5. Click the **Preview** button to view the formatted output.\n\n![collection-preview](/screenshots/send-request/collection-preview.webp)\n",
    "parentName": "api-docs",
    "path": "api-docs/collection-docs"
  },
  "api-docs/folder-docs": {
    "name": "folder-docs",
    "content": "Document a folder\n\n\nTo add Folder-level documentation in Bruno, you need to first create a folder within your collection. Once the folder is created, you can add specific details for the folder-level API documentation.\n\nCreate folder docs\n\n\n1. Go to the collection, click on the **More Options** menu, and select **Create Folder**.\n\n![create-folder](/screenshots/send-request/create-folder.webp)\n\n2. Enter a name for the folder and click the **Create button**.\n3. After creating the folder, navigate to the folder settings.\n\n![folder-level-setting](/screenshots/send-request/folder-level-settings.webp)\n\n4. Go to the Docs tab.\n5. Click the **Edit** button and add your folder-level API documentation.\n6. Click the **Preview** button to view the formatted output.\n\n![docs-preview-folder-level](/screenshots/send-request/docs-preview-folder-level.webp)\n",
    "parentName": "api-docs",
    "path": "api-docs/folder-docs"
  },
  "api-docs/overview": {
    "name": "overview",
    "content": "APIs Documentation\n\n\nBruno allows you to create API documentation at three distinct levels: **Request, Folder, and Collection**.\n\nWith full Markdown support you can write clear, concise, and well-structured documentation at each level supplemented with any relevant screenshots, gifs, or other elements to ensure your users have a seamless onboarding experience.\n\nAlthough Collections are the machine-readable instructions for interacting with an API, offering human-readable instructions to your users can significantly reduce the time to their first interaction.\n\n1. [Document a request](./request-docs.mdx)\n2. [Document a folder](./folder-docs.mdx)\n3. [Document a collection](./collection-docs.mdx)\n",
    "parentName": "api-docs",
    "path": "api-docs/overview"
  },
  "api-docs/request-docs": {
    "name": "request-docs",
    "content": "Document a request\n\n\nIn Bruno, you can create Request-level documentation to provide specific details about your API and its functions. Bruno offers a **Docs** section where you can easily write and manage your request-level documentation.\n\nCreate request docs\n\n\n1. Go to the **Docs** tab within your request.\n2. Click the **Edit** button.\n3. Enter your API details in the provided textarea.\n4. Click the **Preview** button to see the formatted output.\n\n![request-level-edit-docs](/screenshots/send-request/request-level-edit-docs.webp)\n\n![request-level-preview-docs](/screenshots/send-request/request-level-preview-docs.webp)\n",
    "parentName": "api-docs",
    "path": "api-docs/request-docs"
  },
  "auth/add-and-manage-certs": {
    "name": "add-and-manage-certs",
    "content": "Adding and managing certifications \n\n\nBruno supports adding custom Client Authorization (CA) and client certificates to your requests if required by the API you are working with. \n\nAdding a custom CA certificate\n\n\nNavigate to the `Preferences` menu in Bruno and select `Use custom CA Certificate`, then upload the selected file. \n\n![Custom CA Certificate](/screenshots/auth/customcacert.webp)\n\nAdding client certificates to Collections\n\n\nYou can add and manage client certificate(s) on any Collection by going to the `Collection Settings` menu and selecting `Client Certificates`. \n\nSimply enter the domain, designate the type of certificate, and then upload the relevant file(s). \n\n![Client Certificate](/screenshots/auth/clientcerts.webp)",
    "parentName": "auth",
    "path": "auth/add-and-manage-certs"
  },
  "auth/aws-signature": {
    "name": "aws-signature",
    "content": "Authenticate using AWS Signature \n\n\nAWS Signature is the authorization workflow for Amazon Web Services requests. AWS uses a custom HTTP scheme based on a keyed-HMAC (Hash Message Authentication Code) for authentication.\n\nThe official AWS Signature documentation provides more detail:\n\n- [Signing and Authenticating Requests](\n\n- [How to call an API]( \n\nTo use AWS Signature, do the following:\n\n1. In the `Auth` tab for a request, select `AWS Sig V4` from  dropdown list.\n\n2. Enter your *AccessKeyID* and *SecretKey* values. \n\n> For extra security, integrate Bruno with your secret manager to store these values in a single location. Learn more [here](../secrets-management/hashicorp-vault/overview).\n\nThe AWS Signature parameters are as follows:\n\n- Session Token - Required only when using temporary security credentials.\n- Service Name - The service receiving the request.\n- AWS Region - The region receiving the request.\n- Profile Name - name of your AWS signing profile\n\n",
    "parentName": "auth",
    "path": "auth/aws-signature"
  },
  "auth/basic": {
    "name": "basic",
    "content": "Using Basic authentication\n\n\nBasic authentication involves sending a verified username and password with your request. In the request `Auth` tab, select `Basic Auth` from the Auth Type dropdown list.\n\nEnter your API username and password in the Username and Password fields. For extra security, store these in variables.\n\n![Basic](/screenshots/auth/basic.webp)\n\nIn the request Headers, the Authorization header passes the API a Base64 encoded string representing your username and password values, appended to the text `Basic`.",
    "parentName": "auth",
    "path": "auth/basic"
  },
  "auth/bearer": {
    "name": "bearer",
    "content": "Authenticate with a Bearer token\n\n\nBearer tokens enable requests to authenticate using an access key, such as a JSON Web Token (JWT). The token is a text string, included in the request header. \nIn the request `Auth` tab, select `Bearer Token` from the Auth Type dropdown list. In the Token field, enter your API key value. For added security, store it in a variable and reference the variable by name.\n\n![Bearer](/screenshots/auth/bearer.webp)\n\nBruno appends the token value to the text `Bearer` in the required format to the request Authorization header. ",
    "parentName": "auth",
    "path": "auth/bearer"
  },
  "auth/digest": {
    "name": "digest",
    "content": "Authenticate with Digest Access\n\n\nWith Digest auth, the client sends a first request to the API, and the server responds back with details.\nResponse details include a number that can be used only once (a nonce), a realm value, and a 401 Unauthorized response. \nYou then send back an encrypted array of data, including a username and password combined with the data received from the server in the first request. \nThe server uses the passed data to generate an encrypted string and compares it against what you sent to authenticate your request.\n\nIn the Authorization tab for a request, select Digest Auth from the Auth Type dropdown list. \n\n![Digest](/screenshots/auth/digest.webp)\n\n",
    "parentName": "auth",
    "path": "auth/digest"
  },
  "auth/oauth2/authorization-code": {
    "name": "authorization-code",
    "content": "How to Use OAuth2 for the Authorization Code Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_post_response_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_post_response_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_post_response_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/authorization-code"
  },
  "auth/oauth2/client-credentials": {
    "name": "client-credentials",
    "content": "How to Use OAuth2 for the Client Credentials Grant Type\n\n\nOAuth 2.0 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `OAuth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_request_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_request_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_request_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/client-credentials"
  },
  "auth/oauth2/overview": {
    "name": "overview",
    "content": "Oauth 2.0 authentication in Bruno\n\n\nBruno currently supports OAuth2 authentication for the following three grant types:\n\n- [Authorization Code](/auth/oauth2/authorization-code)\n- [Client Credentials](/auth/oauth2/client-credentials)\n- [Password Credentials](/auth/oauth2/password-credentials)\n\n> Bruno does not provide a default callback URL for OAuth2. You will need to configure your own callback URL when setting up OAuth2 authentication.\n",
    "parentName": "auth",
    "path": "auth/oauth2/overview"
  },
  "auth/oauth2/password-credentials": {
    "name": "password-credentials",
    "content": "How to Use OAuth2 for the Password Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. Below are two basic examples of its usage.\n\nCollection level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Open the collection settings and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nif(req.getAuthMode() == 'oauth2' && res.body.access_token) {\n    bru.setVar('access_token_set_by_collection_script', res.body.access_token);\n}\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_collection_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_collection_script` runtime variable in your requests as needed.\n\n\n\n\n\nRequest level\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Create a new empty request and navigate to the **Auth** tab.\n\n2. Select `Oauth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the necessary fields with the relevant information.\n\n3. In the **Scripts** tab, add the following script to the post-response section:\n\n```javascript\"\nbru.setVar('access_token_set_by_request_script', res.body.access_token);\n```\n\nThis script assigns the `access_token` value from the response body to a runtime variable named `access_token_set_by_request_script`, making it available for use in all requests within the collection. You can adjust this script to suit your needs.\n\n4. Return to the **Auth** tab and click the 'Get Access Token' button. You are now free to use the token stored in the `access_token_set_by_request_script` runtime variable in your requests as needed.\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2/password-credentials"
  },
  "auth/oauth2-experimental/authorization-code": {
    "name": "authorization-code",
    "content": "How to Use OAuth2 for the Authorization Code Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. You can configure OAuth2 at either the [collection level](/auth/oauth2-experimental/collection-level-configuration) or [request level](/auth/oauth2-experimental/request-level-configuration).\n\nOAuth2 Configuration\n\n\nSelect `OAuth 2.0` as the authentication method and set the grant type to `Authorization Code`. Fill in the following fields:\n\n- **Callback URL**: The URL where you want to receive the authorization code\n- **Authorization URL**: The endpoint for authorization\n- **Access Token URL**: The endpoint to exchange the code for a token\n- **Client ID**: Your application's client identifier\n- **Client Secret**: Your application's client secret\n- **Scope**: The requested scope\n- **State**: An opaque value to maintain state between the request and callback\n- **Add Credentials to**: Choose how to send credentials (Request Body or Basic Auth Header)\n\nEnable **Use PKCE** if your OAuth provider supports and requires PKCE (Proof Key for Code Exchange).\n\nToken Configuration and Usage\n\n\nBefore getting the access token, configure how you want to use it in your requests:\n\n1. **Token Usage Configuration**:\n   - **Add token to**: Specify how the token should be included in requests:\n     - **Headers**: Adds the token to request headers with a configurable prefix (default: `\"Bearer\"`).\n     - **URL**: Adds the token as a URL query parameter with a configurable parameter name (default: `\"access_token\"`).\n\n> **Note**: You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n>\n> If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n2. Click **Get Access Token** to obtain and store the token.\n\n> **Note**: You can click the 'Clear Cache' button to remove the stored token and request a new one.\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-experimental/authorization-code"
  },
  "auth/oauth2-experimental/client-credentials": {
    "name": "client-credentials",
    "content": "How to Use OAuth2 for the Client Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. You can configure OAuth2 at either the [collection level](/auth/oauth2-experimental/collection-level-configuration) or [request level](/auth/oauth2-experimental/request-level-configuration).\n\nOAuth2 Configuration\n\n\nSelect `OAuth 2.0` as the authentication method and set the grant type to `Client Credentials`. Fill in the following required fields:\n\n- **Access Token URL**: The endpoint to obtain the access token\n- **Client ID**: Your application's client identifier\n- **Client Secret**: Your application's client secret\n- **Scope**: (Optional) The requested scope\n- **Add Credentials to**: Choose how to send credentials (Request Body or Basic Auth Header)\n\nToken Configuration and Usage\n\n\nBefore getting the access token, configure how you want to use it in your requests:\n\n1. **Token Usage Configuration**:\n   - **Add token to**: Specify how the token should be included in requests:\n     - **Headers**: Adds the token to request headers with a configurable prefix (default: `\"Bearer\"`).\n     - **URL**: Adds the token as a URL query parameter with a configurable parameter name (default: `\"access_token\"`).\n\n> **Note**: You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n>\n> If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n2. Click **Get Access Token** to obtain and store the token.\n\n> **Note**: You can click the 'Clear Cache' button to remove the stored token and request a new one.\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-experimental/client-credentials"
  },
  "auth/oauth2-experimental/collection-level-configuration": {
    "name": "collection-level-configuration",
    "content": "Collection-Level OAuth2 Configuration\n\n\nOverview\n\n\nBruno allows you to configure OAuth2 authentication at the collection level, making it reusable across all requests within that collection. This guide explains how to set up and use OAuth2 authentication effectively.\n\nSetting Up OAuth2\n\n\n1. **Access Collection Settings**\n\n   - Open your collection\n   - Navigate to Collection Settings\n   - Select the \"Auth\" tab\n\n2. **Configure OAuth2**\n   - Choose \"OAuth 2.0\" from the authentication dropdown\n   - Select your preferred grant type\n   - Fill in the required OAuth2 parameters\n\nSupported Grant Types\n\n\nBruno supports three OAuth2 grant types:\n\n- [Authorization Code](/auth/oauth2-experimental/authorization-code)\n- [Client Credentials](/auth/oauth2-experimental/client-credentials)\n- [Password Credentials](/auth/oauth2-experimental/password-credentials)\n\nManaging Access Tokens\n\n\nGenerating Tokens\n\n\n1. Configure OAuth2 parameters as per grant type.\n2. You can choose where to add this token in the request by selecting the \"Add token to\" dropdown:\n   - Headers\n     - Adds the token to the request headers\n     - Configure the header prefix (defaults to \"Bearer\")\n   - URL\n     - Adds the token to the request URL\n     - Configure the query parameter name (defaults to \"access_token\")\n3. Click \"Get Access Token\" to obtain and store the token.\n\n> **Note**: You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n>\n> If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\nUsing Collection-Level OAuth2 in Requests\n\n\nWhen a collection has OAuth2 configured, individual requests can use the authentication in two ways:\n\nMethod 1: Collection Inheritance (Recommended)\n\n\n- Open request settings\n- Select \"Auth\" tab\n- Choose \"Inherit from collection\"\n- The token will be automatically added to the request according to your collection-level configuration (Headers or URL)\n\n\n  \n  Your browser does not support the video tag.\n\n\nMethod 2: Direct Token Reference\n\n\nYou can manually reference the collection's OAuth2 token in your requests using the variable format `{{$oauth2..access_token}}` in headers or query parameters.\n\nExample\n\n\nAs shown in the video above, the Token ID value will be `{{$oauth2.credentials.access_token}}`\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-experimental/collection-level-configuration"
  },
  "auth/oauth2-experimental/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\n\nOauth 2.0 authentication in Bruno\n\n\n  \n  This OAuth2 implementation is **only available in the experimental build**. You can download it [here](\n\nIf you're using a stable version of Bruno, please refer to the [legacy OAuth2 documentation](/auth/oauth2/overview).\n\n\n\nThis document describes the new OAuth2 implementation available in experimental builds of Bruno. This new approach simplifies authentication handling compared to the previous version.\n\nOverview\n\n\nBruno supports OAuth2 authentication at both collection and request levels:\n\n- **[Collection Level](/auth/oauth2-experimental/collection-level-configuration)**: Configure once and share across multiple requests\n- **[Request Level](/auth/oauth2-experimental/request-level-configuration)**: Configure for specific requests, overriding collection settings if needed\n\nFeatures & Improvements\n\n\n1. **Simplified Configuration**: You no longer need to separately configure authorization and resource requests\n2. **Automatic Token Management**: No scripting is required to set headers for the resource URL\n3. **Automatic Token Injection**: Bruno automatically adds the token to request headers or parameters based on your configuration\n4. **Token Data Access**: Access token data using variables: `{{$oauth2..access_token}}` within the collection\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-experimental/overview"
  },
  "auth/oauth2-experimental/password-credentials": {
    "name": "password-credentials",
    "content": "How to Use OAuth2 for the Password Credentials Grant Type\n\n\nOAuth2 authentication can be implemented in various ways, depending on the collection structure and specific requirements. You can configure OAuth2 at either the [collection level](/auth/oauth2-experimental/collection-level-configuration) or [request level](/auth/oauth2-experimental/request-level-configuration).\n\nOAuth2 Configuration\n\n\nSelect `OAuth 2.0` as the authentication method and set the grant type to `Password Credentials`. Fill in the following required fields:\n\n- **Access Token URL**: The endpoint to obtain the access token\n- **Username**: The resource owner's username\n- **Password**: The resource owner's password\n- **Client ID**: Your application's client identifier\n- **Client Secret**: Your application's client secret\n- **Scope**: (Optional) The requested scope\n- **Add Credentials to**: Choose how to send credentials (Request Body or Basic Auth Header)\n\nToken Configuration and Usage\n\n\nBefore getting the access token, configure how you want to use it in your requests:\n\n1. **Token Usage Configuration**:\n   - **Add token to**: Specify how the token should be included in requests:\n     - **Headers**: Adds the token to request headers with a configurable prefix (default: `\"Bearer\"`).\n     - **URL**: Adds the token as a URL query parameter with a configurable parameter name (default: `\"access_token\"`).\n\n> **Note**: You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n>\n> If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\n2. Click **Get Access Token** to obtain and store the token.\n\n> **Note**: You can click the 'Clear Cache' button to remove the stored token and request a new one.\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-experimental/password-credentials"
  },
  "auth/oauth2-experimental/request-level-configuration": {
    "name": "request-level-configuration",
    "content": "Request-Level OAuth2 Configuration\n\n\nOverview\n\n\nBruno allows you to configure OAuth2 authentication at the request level, providing flexibility to use different OAuth2 settings for specific requests. This guide explains how to set up and use OAuth2 authentication for individual requests.\n\nSetting Up OAuth2\n\n\n1. **Access Request Settings**\n\n   - Open your request\n   - Navigate to Request Settings\n   - Select the \"Auth\" tab\n\n2. **Configure OAuth2**\n   - Choose \"OAuth 2.0\" from the authentication dropdown\n   - Select your preferred grant type\n   - Fill in the required OAuth2 parameters\n\nSupported Grant Types\n\n\nBruno supports three OAuth2 grant types:\n\n- [Authorization Code](/auth/oauth2-experimental/authorization-code)\n- [Client Credentials](/auth/oauth2-experimental/client-credentials)\n- [Password Credentials](/auth/oauth2-experimental/password-credentials)\n\nManaging Access Tokens\n\n\n1. Configure OAuth2 parameters\n2. You can choose where to add this token in the request by selecting the \"Add token to\" dropdown:\n   - Headers\n     - Adds the token to the request headers\n     - Configure the header prefix (defaults to \"Bearer\")\n   - URL\n     - Adds the token to the request URL\n     - Configure the query parameter name (defaults to \"access_token\")\n3. Click \"Get Access Token\" to obtain and store the token.\n\n> **Note**: You may optionally assign a Token ID to your token. If you do, you can reference this token in requests using the format `{{$oauth2..access_token}}` (replace `` with your Token ID).\n>\n> If you use the same Token ID in multiple OAuth requests, Bruno will overwrite the existing token data. Make sure to use unique Token IDs for different OAuth configurations.\n\nUsing Request-Level OAuth2\n\n\nYou can use the OAuth2 token in your request in two ways:\n\nMethod 1: Automatic Token Addition\n\n\n- Configure the token location in the Auth settings (Headers or URL)\n- Bruno will automatically add the token to your request based on your configuration\n\n\n  \n  Your browser does not support the video tag.\n\n\nMethod 2: Direct Token Reference\n\n\nYou can manually reference the request's OAuth2 token in your requests using the variable format `{{$oauth2..access_token}}` in either headers or query parameters.\n\nExample\n\n\nAs shown in the video above, the Token ID value will be `{{$oauth2.credentials.access_token}}`\n\n\n  \n  Your browser does not support the video tag.\n\n\nNote on Collection-Level OAuth2\n\n\nIf you've configured OAuth2 at the collection level, you can:\n\n- Override it by setting up request-level OAuth2 configuration\n- Inherit it by selecting \"Inherit from collection\" in the request's Auth settings\n\n\n\n\n",
    "parentName": "auth",
    "path": "auth/oauth2-experimental/request-level-configuration"
  },
  "auth/overview": {
    "name": "overview",
    "content": "import { Callout } from 'nextra/components'\n \nAuthentication in Bruno\n\n\nBruno allows you to send authentication details with your API requests.\nAuthentication methods can be set on the request level or collection level, if you want all of your requests to use the same method.\n\n\n  Some APIs will require a digital certificate to establish a client's identity.\n  You can add your certificate authority (CA) or client certificates to Bruno.\n  See [Add and Manage Certificates](./add-and-manage-certs) for more\n  information.\n\n\nYou can pass auth details along with any request in Bruno in the header, body, or as a parameter.\nIf you enter your auth details to the `Auth` tab of your requests, we will automatically populate the relevant parts of the request for your chosen auth method.\n\nBruno currently supports the following authentication protocols:\n\n\n- [OAuth 2.0](/auth/oauth2/overview)\n- [OAuth 2.0 (Experimental)](/auth/oauth2-experimental/overview)\n- [AWS Sig v4](/auth/aws-signature)\n- [Basic Auth](/auth/basic)\n- [Bearer Auth](/auth/bearer)\n- [Digest Auth](/auth/digest)\n",
    "parentName": "auth",
    "path": "auth/overview"
  },
  "bru-cli/overview": {
    "name": "overview",
    "content": "Bruno CLI\n\n\nWith Bruno CLI, you can run your API collections with ease using simple command line commands.\n\nThis makes it easier to test your APIs in different environments, automate your testing process, and integrate your API tests with your continuous integration and deployment workflows.\n\nInstallation\n\nTo install the Bruno CLI, use the node package manager of your choice, such as NPM:\n```bash copy\nnpm install -g @usebruno/cli\n```\n\nGetting Started\n\n\nNavigate to the directory where your API collection resides, and run the following command:\n\n```bash copy\nbru run\n```\n\nThis will run all the requests in your collection. If you want to run a single request, specify its filename:\n\n```bash copy\nbru run request.bru\n```\n\nRunning Requests in a Folder\n\nTo run all the requests within a folder, use:\n\n```bash copy\nbru run folder\n```\n\nUsing Environments\n\nIf you need to use a specific environment, you can pass it with the --env option:\n\n```bash copy\nbru run folder --env Local\n```\n\nPassing Environment Variables\n\n\n> Variables marked as secrets in Bruno app are not accessible via the CLI. Pass them directly as command-line arguments.\n\n```bash copy\nbru run folder --env Local --env-var JWT_TOKEN=1234\n```\n\nRunning a Collection with a CSV File\n\nIf you need to run a collection using data from a CSV file, specify the path to the file with the `--csv-file-path` option:\n\n```bash copy\nbru run folder --csv-file-path /path/to/csv/file.csv\n```\n\nRunning a Collection with a JSON File\n\nTo run a collection using data from a JSON file, provide the file path using the `--json-file-path` option:\n\n```bash copy\nbru run folder --json-file-path /path/to/json/file.json\n```\n> This feature requires Bruno CLI version 1.35.0 or higher.\n\n\nOutputting Results\n\nTo save the results of your API tests to a file, use the --output option:\n\n```bash copy\nbru run folder --output results.json\n```\n\nSkipping Specific Headers in the Report\n\n\nIf you want to exclude certain headers from the report, use the `--reporter-skip-headers` option. You can list multiple headers to skip, separated by spaces.\n\n```bash\nbru run --reporter-html results.html --reporter-skip-headers \"Authorization\" \"Content-Type\" \"Date\"\n```\n\nSkip All Headers in the Report\n\n\nTo exclude all headers from the report, use the `--reporter-skip-all-headers` option. This will remove all headers from the output report, ensuring a cleaner result.\n\n```bash copy\nbru run --reporter-html results.html --reporter-skip-all-headers\n```\n\nUsing Client Certificates for API Requests\n\n\nIf your API requests require client certificates for authentication, you can specify using the `--client-cert-config` option. The configuration should be provided in a JSON file. Here's an example of how to use this option:\n\n```bash copy\nbru run folder --client-cert-config /path/to/client-cert-config.json\n```\n\nThe client-cert-config.json file should contain the following fields:\n\n```json\n{\n  \"enabled\": true,\n  \"certs\": [\n    {\n      \"domain\": \"usebruno.com\",\n      \"type\": \"cert\",\n      \"certFilePath\": \"certs/server_1.crt\",\n      \"keyFilePath\": \"private/server_1.key\",\n      \"passphrase\": \"Iu$eBrun0_#Secure!\"\n    },\n    {\n      \"domain\": \"the-example.com\",\n      \"type\": \"pfx\",\n      \"pfxFilePath\": \"pfx/server_3.pfx\",\n      \"passphrase\": \"L!ghT_Y@g@mi_2024!\"\n    }\n  ]\n}\n```\nAdding Delay\n\nIf you need to add a delay between requests during the execution of your API collection, you can use the `--delay` option.\n\nExample:\n```bash copy\nbru run . --delay 1000\n```\nGenerating Reports\n\n\nBruno CLI provides built-in support for generating reports in three formats: **JSON**, **JUnit**, and **HTML**. These reports help with analyzing test results and integrating with various CI/CD tools.\n\nYou can generate any combination of these reports and even run them simultaneously.\n\nJSON Report\n\n\nTo generate a report in JSON format, use the `--reporter-json` option:\n\n```bash copy\nbru run request.bru --reporter-json results.json\n```\n\nThis will output the test results in a results.json file, which can be useful for further processing or programmatic analysis.\n\nJUnit Report\n\n\nTo generate a report in JUnit format, use the --reporter-junit option:\n\n```bash copy\nbru run request.bru --reporter-junit results.xml\n```\n\nThe results.xml file will be in a format compatible with JUnit, making it ideal for integration with CI/CD pipelines that rely on JUnit reporting.\n\n\nHTML Report\n\n\nTo generate a human-readable HTML report, use the --reporter-html option:\n\n```bash copy\nbru run request.bru --reporter-html results.html\n```\n\nThis will create an results.html file that provides a visual representation of the test outcomes, ideal for quick reviews.\n\nRunning Multiple Reporters Simultaneously\n\n\nYou can generate multiple reports at once by specifying more than one reporter option. For example, to generate JSON, JUnit, and HTML reports simultaneously, run:\n\n```bash copy\nbru run request.bru --reporter-json results.json --reporter-junit results.xml --reporter-html results.html\n```\n\nThis command will create three files: results.json, results.xml, and results.html, allowing you to analyze the results in different formats as needed.\n\n\nOptions\n\n\n| Option                       | Details                                                                       |\n| ---------------------------- | ----------------------------------------------------------------------------- |\n| -h, --help                   | Show help                                                                     |\n| --version                    | Show version number                                                           |\n| -r                           | Indicates a recursive run (default: false)                                    |\n| --cacert [string]            | CA certificate to verify peer against                                         |\n| --env [string]               | Specify environment to run with                                               |\n| --env-var [string]           | Overwrite a single environment variable, multiple usages possible             |\n| -o, --output [string]        | Path to write file results to                                                 |\n| -f, --format [string]        | Format of the file results; available formats are \"json\" (default) or \"junit\" |\n| --reporter-json [string]     | Path to generate a JSON report                                                |\n| --reporter-junit [string]    | Path to generate a JUnit report                                               |\n| --reporter-html [string]     | Path to generate an HTML report                                               |\n| --insecure                   | Allow insecure server connections                                             |\n| --tests-only                 | Only run requests that have tests                                             |\n| --bail                       | Stop execution after a failure of a request, test, or assertion               |\n| --csv-file-path              | CSV file to run the collection with                                           |\n| --reporter--skip-all-headers | Skip all headers in the report                                                |\n| --reporter-skip-headers      | Skip specific headers in the report                                           |\n| --client-cert-config         | Client certificate configuration by passing a JSON file                       |\n| --delay [number]             | Add delay to each request                                                     |\n\nDemo\n\n![bru cli](/screenshots/cli-demo.webp)\n\nSupport\n\nIf you encounter any issues or have any feedback or suggestions, please raise them on our [GitHub repository](\n",
    "parentName": "bru-cli",
    "path": "bru-cli/overview"
  },
  "bru-lang/language": {
    "name": "language",
    "content": "Language Design\n\n\nA Bru file is made up of blocks.\nThere are three kinds of blocks\n- Dictionary block\n- Text block\n- Array block\n\nDictionary block\n\nA dictionary block contains a set of key value pairs. \n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer 123\n  ~transaction-id: {{transactionId}}\n}\n```\nAny key in the dictionary block can be prefixed with `~` to indicate that it is disabled.\n\nText block\n\nA text block is a set of lines\n```bash\nbody {\n  {\n    \"hello\": \"world\"\n  }\n}\n\ntests {\n  expect(res.status).to.equal(200);\n}\n```\n\nArray block\n\nAn array block is a list of strings\n```bash\nvars:secret [\n  access_key,\n  access_secret,\n  ~transactionId\n]\n```\nAny key in the array block can be prefixed with `~` to indicate that it is disabled.\n\n\n\n\n\n",
    "parentName": "bru-lang",
    "path": "bru-lang/language"
  },
  "bru-lang/overview": {
    "name": "overview",
    "content": "Bru Markup Language\n\n\nBru is a simple markup language that utilizes plain text files to document and organize information for your API requests.\n\nThe API requests in your collections are stored as plain text files using this language.\n\nThis allows you to save your API collections in a folder within your code repository, and use your preferred version control system to manage and share them with your team. Collaboration on your API collections can be done through pull requests, as the human-readable file format makes it easy for developers to understand the changes made to the API collection.\n\nBelow is a sample of a Bru file for a `GET` request with some query params\n\n![bru lang sample](/screenshots/github-collection.webp)\n\nYou can checkout the sample repository which contains GitHub rest API collection [here](\n\nIf you are wondering why we designed a DSL instead of just using JSON/YAML, you can checkout this [github discussion](\n",
    "parentName": "bru-lang",
    "path": "bru-lang/overview"
  },
  "bru-lang/samples": {
    "name": "samples",
    "content": "Samples\n\n\nHere are a few sample Bru files.\n\nGET\n\n```bash\nget {\n  url: \n}\n```\n\nGET with headers\n\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nPOST with body\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"apiKey\": \"secret\",\n    \"numbers\": \"9988776655\",\n    \"message\": \"Woof! lets play with some apis\"\n  }\n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nScripting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\n\nTesting\n\n```bash\npost {\n  url: \n}\n\nbody {\n  {\n    \"username\": \"johnnash\",\n    \"password\": \"governingdynamics\"\n  }\n}\n\ntests {\n  test(\"should be able to login\", function() {\n    expect(res.status).to.equal(201);\n  });\n\n  test(\"should receive the token\", function() {\n    expect(res.body.token).to.be.a('string');\n  });\n}\n```",
    "parentName": "bru-lang",
    "path": "bru-lang/samples"
  },
  "bru-lang/syntax-highlighting": {
    "name": "syntax-highlighting",
    "content": "Syntax Highlighting Support\n\n\nBruno has editor extension released for VS Code.  You can download it from the [Visual Studio Marketplace](\n\nExtensions for IntelliJ and the JetBrains family of IDEs are under development.\n",
    "parentName": "bru-lang",
    "path": "bru-lang/syntax-highlighting"
  },
  "bru-lang/tag-reference": {
    "name": "tag-reference",
    "content": "Bru Tag Reference\n\n\nmeta\n\nStore metadata about your request\n```bash\nmeta {\n  name: Get users,\n  type: http\n  seq: 1\n}\n```\n\nThe `seq` is used to store the sequence number. This decides the sort position of your request in the UI.\nThe `type` can be either `http` or `graphql`\n\nget\n\n\nMake a `GET` http call\n```bash\nget {\n  url: \n}\n```\npost\n\n\nMake a `POST` http call\n```bash\npost {\n  url: \n}\n```\nput\n\n\nMake a `PUT` http call\n```bash\nput {\n  url: \n}\n```\ndelete\n\n\nMake a `DELETE` http call\n```bash\ndelete {\n  url: \n}\n```\noptions\n\n\nMake a get `OPTIONS` call\n```bash\noptions {\n  url: \n}\n```\ntrace\n\n\nMake a `TRACE` http call\n```bash\ntrace {\n  url: \n}\n```\nconnect\n\n\nMake a `CONNECT` http call\n```bash\nconnect {\n  url: \n}\n```\nhead\n\n\nMake a `HEAD` http call\n```bash\nhead {\n  url: \n}\n```\nquery\n\n\nThe request query params\n```bash\nget {\n  url: \n}\n\nparams:query {\n  apiKey: secret\n  numbers: 9988776655\n  message: hello\n}\n```\npath\n\n\nThe request path params\n```bash\nget {\n  url: \n}\n\nparams:path {\n  userId: 13\n}\n```\nheaders\n\n\nThe request query headers\n```bash\nget {\n  url: \n}\n\nheaders {\n  content-type: application/json\n  Authorization: Bearer topsecret\n}\n```\n\nbody\n\nThe request body (defaults to json)\n```bash\nbody {\n  {\n    username: 'john',\n    password: 'governingdynamics'\n  }\n}\n```\nbody:text\n\nThe request body as text\n```bash\nbody:text {\n  This is a text body\n}\n```\nbody:xml\n\nThe request body as xml\n```bash\nbody:xml {\n  \n    John\n    30\n  \n}\n```\nbody:form-urlencoded\n\nThe request body as form-urlencoded\n```bash\nbody:form-urlencoded {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:multipart-form\n\nThe request body as multipart-form\n```bash\nbody:multipart-form {\n  apikey: secret\n  numbers: +91998877665\n  ~message: hello\n}\n```\nbody:graphql\n\nThe request body as graphql\n```bash\nbody:graphql {\n  {\n    launchesPast {\n      launch_site {\n        site_name\n      }\n      launch_success\n    }\n  }\n}\n```\nbody:graphql:vars\n\nThe request body as graphql vars\n```bash\nbody:graphql:vars {\n  {\n    \"limit\": 5\n  }\n}\n```\nscript:pre-request\n\nThe request body as pre-request\n```bash\nscript:pre-request {\n  req.setHeader(\"Authorization\", \"{{token}}\");\n}\n```\nscript:post-response\n\nThe request body as post-response\n```bash\nscript:post-response {\n  bru.setVar(\"token\", res.body.token);\n}\n```\ntest\n\nThe tests\n```bash\nbody:test {\n  expect(res.status).to.equal(200);\n}\n```\n",
    "parentName": "bru-lang",
    "path": "bru-lang/tag-reference"
  },
  "get-started/bruno-basics/create-a-collection": {
    "name": "create-a-collection",
    "content": "Creating a Collection\n\n\n> _If you have an existing collection inside of another tool that you would like to import, please see [Importing Collections](\n\nCreate a collection by selecting `Create Collection` from the **home screen** or **top left corner** of the app.\n\n![create collection dialog](/screenshots/get-started/bruno-basics/create-collection/bruno_collection-1.webp)\n\nA popup dialog will appear, asking you to name your collection and choose its location in the file system. You can also choose to edit the generated folder's name.\n\n![create collection dialog](/screenshots/get-started/bruno-basics/create-collection/bruno_collection-2.webp)\n\nSelect `Create` and ... Congratulations! You have successfully created your first collection into Bruno!\n\n[Add a request]( to your collection as a next step!\n\n> _If you’re looking to collaborate and share with your team, please see [Collaboration in Bruno](\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-collection"
  },
  "get-started/bruno-basics/create-a-folder": {
    "name": "create-a-folder",
    "content": "import { Callout } from \"nextra/components\";\n\nCreate a Folder\n\n\nBruno helps you organize your API requests efficiently by grouping them into folders. You can create a structured hierarchy that matches your API's organization, making it easier to manage and navigate your collections.\n\nCreating a New Folder\n\n\n1. Select your Collection from the sidebar.\n2. Click on the `···` button.\n3. Select `New Folder` from the dropdown menu.\n\n![create folder](/screenshots/get-started/bruno-basics/create-folder/1-create-new-folder.webp)\n\n4. Enter a name for your folder.\n5. Click `Create` to finish.\n\n![new folder dialog](/screenshots/get-started/bruno-basics/create-folder/2-create-sample-folder.webp)\n\nYour new folder is now ready to organize your requests!\n\nCustom Folder Names\n\n\n\n  Starting with [Bruno v1.40.0 ↗]( you can\n  now use special characters in folder names and customize how they appear in\n  the filesystem. This gives you more flexibility in organizing your collections\n  while maintaining compatibility.\n\n\nYou can use any characters in your folder names, including special characters like `/`, `[`, `]`, `*`, etc. Bruno automatically handles filesystem compatibility by replacing unsupported characters with `-` in the filenames while preserving your original folder name.\n\nHow to View or Customize Filesystem Names\n\n\n1. Select \"Show Filesystem Name.\"\n\n![show filesystem name](/screenshots/get-started/bruno-basics/create-folder/3-show-file-system-name.webp)\n\n2. You can now see how your folder name is stored on the filesystem.\n\n![filesystem name view](/screenshots/get-started/bruno-basics/create-folder/4-file-system-name.webp)\n\n3. (Optional) Click the edit icon to customize the filesystem name while keeping your display name intact.\n\nThis feature allows you to:\n\n- Create more descriptive folder organization.\n- Use special characters freely.\n- Maintain filesystem compatibility automatically.\n- Keep your collection structure clean and organized.\n\nExample\n\n\nYou could name a folder \"API [v2.0] / Authentication\" and Bruno will automatically handle the filesystem compatibility while preserving your desired display name.\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-folder"
  },
  "get-started/bruno-basics/create-a-request": {
    "name": "create-a-request",
    "content": "import { Callout } from 'nextra/components'\n \nCreating a Request\n\n\nBruno makes it easy to work with various API protocols - whether you're building RESTful services with HTTP, designing GraphQL APIs, or converting cURL commands into reusable requests. With support for all standard HTTP methods (GET, POST, PUT, DELETE, etc.), you can create, test, and manage your API requests efficiently.\n\nLet's walk through how to create your first request:\n\nCreate a New Request in Bruno\n\n\n1. Go to your Collection, and click on the `···` button.\n2. Select `New Request` in the dropdown menu.\n\n![create request dialog](/screenshots/get-started/bruno-basics/create_request/1-create-new-request.webp)\n\n3. In the dialog that appears, choose:\n   - Request Type (HTTP, GraphQL, or from cURL)\n   - Request Name\n   - HTTP Method (GET, POST, PUT, etc.)\n   - URL\n\n![create-new-request](/screenshots/get-started/bruno-basics/create_request/2-create-request.webp)\n\n4. Click `Create` to finish.\n\nYou have successfully created your first request in Bruno! Feel free to add headers, query parameters, and a request body to your request, or play around with the other options available.\n\nCustom Request Filenames\n\n\n\n  Starting with [Bruno v1.40.0 ↗]( you can\n  now use special characters in request names and customize how they appear in\n  the filesystem. This gives you more flexibility in organizing your collections\n  while maintaining compatibility.\n\n\nYou can use any characters in your request names, including special characters like `/`, `[`, `]`, `*`, etc. Bruno automatically handles filesystem compatibility by replacing unsupported characters with `-` in the filenames while preserving your original request name.\n\nTo view or customize the filesystem name\n\n\n1. Select \"Show Filesystem Name.\"\n\n![file-system-name](/screenshots/get-started/bruno-basics/create_request/3-file-system-option.webp)\n\n2. You can now see how your request name is stored on the filesystem.\n\n![file-system-name](/screenshots/get-started/bruno-basics/create_request/4-file-name-special-char.webp)\n\n3. (Optional) Click the edit icon to customize the filename while keeping your display name intact.\n\nThis feature gives you complete freedom in naming your requests while ensuring filesystem compatibility.\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-request"
  },
  "get-started/bruno-basics/create-a-test": {
    "name": "create-a-test",
    "content": "import { Callout } from \"nextra/components\";\n\nCreate a Test\n\n\n\n  Bruno uses the [Chai library]( so you can follow the same syntax for writing\n  assertions in your tests.\n\n\nTo ensure your API is behaving as expected, create a test against it.\n\nBruno supports writing tests by through either:\n\n- Assertions to declaratively write tests\n- JavaScript\n\nAssertion\n\n\nTo get familiar with testing, open a Collection, select a request, and click on the `Assertions` tab\n\nYou can then dictate an expression, operator, and value to test against.\n\n![bru assertions](/screenshots/get-started/bruno-basics/create_test/bru_test_assert.webp)\n\nTesting with JavaScript\n\n\nBruno also supports writing automation test scripts in JavaScript for more advanced API testing scenarios. By automating your tests, you can increase efficiency and coverage, and integrate testing into CI/CD pipelines.\n\nExample\n\n\n```js copy\ntest(\"should be able to login\", function () {\n  const data = res.getBody();\n  expect(res.getStatus()).to.equal(200);\n});\n\ntest(\"should return json\", function () {\n  const data = res.getBody();\n  expect(res.getBody()).to.eql({\n    hello: \"Bruno\",\n  });\n});\n```\n\n![bru lang sample](/screenshots/test-script.webp)\n\nIn this example:\n\n1. The first test checks that the response status is 200 (indicating a successful login).\n2. The second test verifies that the response body is equal to the expected JSON object.\n\n\n  For more advanced testing scenarios and tips, view the\n  [Scripting]( docs.\n\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/create-a-test"
  },
  "get-started/bruno-basics/download": {
    "name": "download",
    "content": "import { Tabs } from 'nextra/components'\n\nDownload Bruno\n\n\nBruno is available on MacOS, Windows and Linux. \nVisit the [Download page]( and select the option for your operating system. \n\n\n\n  \n    Download Bruno on MacOS from [here](\n\n    To install via Homebrew, run the following command:\n    \n    ```bash\n    brew install bruno\n    ```\n  \n  \n    Download Bruno on Windows from [here](\n    \n    For Chocolatey, use the following command:\n    ```bash\n    choco install bruno\n    ```\n\n    For Winget, use the following command:\n     ```bash\n    winget install Bruno.Bruno\n    ```\n\n    For Scoop, use the following command:\n     ```bash\n    scoop install bruno\n    ```\n\n  \n  \n    Download Bruno on Linux from [here](\n\n    For Debian-based distributions (like Ubuntu), use the following command:\n    \n    ```bash\n    sudo apt install bruno\n    ```\n\n    For Flatpak, use the following command:\n    \n    ```bash\n    flatpak install flathub com.usebruno.Bruno\n    ```\n\n    For Snap, use the following command:\n    \n    ```bash\n    sudo snap install bruno\n    ```\n  \n\n\n\nYou can also check out the [GitHub Releases]( for the latest release notes, bug fixes, and new features included in each release.\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/download"
  },
  "get-started/bruno-basics/run-a-collection": {
    "name": "run-a-collection",
    "content": "Run a Collection\n\n\nRunning your Bruno Collection allows you to interact with, and test, an API. We allow you to run your Collections a few different ways:\n\nCollection Runner\n\n\nWe have a built-in Collection Runner that allows for **unlimited** runs.\n\nRun your Collection by either clicking the `...` button next to your Collection in the sidebar then select `Run`\n\n![Click Run](/screenshots/get-started/bruno-basics/run_collection/run_collection.webp)\n\nor click the Collection Runner icon in the top bar of the application.\n\n![Collection Runner](/screenshots/get-started/bruno-basics/run_collection/runnericon.webp)\n\nYou'll now have access to run the collection, add parameters, or set a delay between requests.\n\n> _Data-driven testing by using a .CSV file is available in our Golden and Ultimate Edition_\n\n![Collection Runner](/screenshots/get-started/bruno-basics/run_collection/runner.webp)\n\nAutomating Runs in CI/CD\n\n\nBruno offers a command-line utility to run Collections. This allows you to integrate your tests into a CI and build process.\n\nFor more information, head to the page for [Bruno CLI](\n",
    "parentName": "get-started",
    "path": "get-started/bruno-basics/run-a-collection"
  },
  "get-started/configure/proxy-config": {
    "name": "proxy-config",
    "content": "Configuring Proxy Settings in Bruno\n\n\nA proxy is an intermediary server that sits between a client application (like Bruno) and the destination server that the client is communicating with (like an API). The proxy server acts as a security barrier, making requests on your behalf to websites and other internet resources, and preventing others from accessing your internal network.\n\nIf your machine sits behind a corporate network or firewall, you may need to configure the proxy settings in Bruno in order for requests to be made. By default, Proxy is set to off.\n\nBelow are steps for configuring your proxy settings at different levels within Bruno.\n\n**1. Accessing Proxy Settings**\n\n\n1. Open Bruno.\n2. Click on the **Preferences** section.\n\n![preferences](/screenshots/get-started/config/proxy/1-preferences.webp)\n\n3. Navigate to the **Proxy** tab in the sidebar.\n\n![proxy-settings](/screenshots/get-started/config/proxy/2-global-proxy.webp)\n\n**2. Configuring Proxy Mode**\n\n\nBruno provides three options for proxy mode:\n\n- **Off**: Disables proxy usage.\n- **On**: Enables proxy and routes requests through the configured proxy.\n- **System Proxy**: Uses the system-wide proxy settings.\n\nSelect **On** if you want to configure a custom proxy.\n\n**3. Selecting Proxy Protocol**\n\n\nBruno supports different proxy protocols. Choose one of the following:\n\n- **HTTP**\n- **HTTPS**\n- **SOCKS4**\n- **SOCKS5**\n\n**4. Entering Proxy Details**\n\n\nFill in the required fields:\n\n- **Hostname**: The proxy server's domain or IP address (e.g., `example.com`).\n- **Port**: The port number for the proxy connection (e.g., `3000`).\n\n**5. Enabling Authentication (Optional)**\n\n\nIf your proxy requires authentication:\n\n1. Check the **Auth** checkbox.\n2. Enter the **Username**.\n3. Enter the **Password** (Click the eye icon to reveal the password if needed).\n\n**6. Configuring Proxy at Collection Level**\n\n\nThere may be instances in which your collection needs to use a different proxy than what you have configured globally. Configuring proxy settings at the collection level will override any configuration you've made in the preferences section.\n\nBelow are instructions on proxy settings at the collection level:\n\n1. Open the collection settings.\n2. Navigate to the **Proxy** tab.\n\n![collection-proxy](/screenshots/get-started/config/proxy/3-collection-proxy.webp)\n\n**Choose the Configuration Mode:**\n\n\n- **Global**: Uses the main proxy settings from Preferences.\n- **Enabled**: Enables a custom proxy for this collection.\n- **Disabled**: Disables the proxy for this collection.\n\n3. Choose **global, enabled, or disabled**.\n4. Enter the **Hostname, Port, Protocol, Username, and Password** if needed.\n5. Click **Save** to apply the settings.\n\n**7. Saving Proxy Configuration**\n\n\nAfter entering the proxy details, click the **Save** button to apply the changes.\n\n---\n\nYour proxy settings are now configured in Bruno.\n",
    "parentName": "get-started",
    "path": "get-started/configure/proxy-config"
  },
  "get-started/configure/settings": {
    "name": "settings",
    "content": "Settings\n\n\nYou can customize Bruno settings according to your preferences. Bruno offers a variety of settings that can be tailored to suit your needs. Key settings include:\n\n- [General](#general)\n- [Display](#display)\n- [Proxy](#proxy)\n- [License](#license)\n- [Keybindings](#keybindings)\n- [Secrets](#secrets)\n- [Support](#support)\n- [About](#about)\n\nThese are the core settings that you can adjust to optimize your Bruno experience.\n\nGeneral\n\n\nThe General settings include options for SSL/TLS, Custom CA certificates, and Cookies. You can customize how cookies are handled by choosing to store and send them automatically, or simply uncheck the box if you prefer not to store cookies.\n\n![general-settings](/screenshots/get-started/config/settings/general-settings.webp)\n\nDisplay\n\n\nIn the Display section, you can control the appearance of the Bruno, choosing between Dark, Light, or System mode, based on your preference. Additionally, you can customize the code editor font to suit your style.\n\n![display-settings](/screenshots/get-started/config/settings/display-settings.webp)\n\nProxy\n\n\nYou can customize the Proxy settings by selecting On, Off, or System, depending on your needs. For more details, you can refer to the [Proxy guide here](./proxy-config.mdx) to learn more. By default, the Proxy setting is Off in Bruno.\n\n![proxy-settings](/screenshots/get-started/config/settings/proxy-settings.webp)\n\nLicense\n\n\nBruno offers Ultimate and Pro plans for premium users. You can refer to the [Licensing guide](/license-management/overview.mdx) to learn more about the features and benefits of each plan.\n\n![license-settings](/screenshots/get-started/config/settings/license-settings.webp)\n\nKeybindings\n\n\nThe Keybindings section provides details about Bruno’s keyboard shortcuts.\n\n![keybindings](/screenshots/get-started/config/settings/key-settings.webp)\n\nSecrets\n\n\nThere are three primary ways to manage secrets in Bruno, which you can learn about in the [Secret Management Overview](/secrets-management/overview).\n\nThis setting controls the integration with a Vault for secret management, which is available in Bruno **Ultimate Edition**.\n\n![vault-secrets](/screenshots/get-started/config/settings/vault-server.webp)\n\nSupport\n\n\nIf you encounter issues or need assistance, you can access a range of troubleshooting resources to help resolve your problem quickly.\n\n![support](/screenshots/get-started/config/settings/support.webp)\n\nAbout\n\n\nView application details and enable the auto-update feature to keep your app up to date automatically.\n\n![about](/screenshots/get-started/config/settings/about.webp)\n",
    "parentName": "get-started",
    "path": "get-started/configure/settings"
  },
  "get-started/history": {
    "name": "history",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nRequest History \n\n\nThe History feature in Bruno allows you to view a detailed log of all the requests you've executed and worked with within your collections. This feature helps you track and revisit past actions, making it easier to manage and troubleshoot your workflow.\n\nHow It Works\n\n\nThe History feature automatically tracks the actions and requests made within your collections. Each time you run a request or make changes, it is logged in the history, providing you with a comprehensive timeline of your interactions.\n\nView History Logs\n\n\nTo view your history follow the below steps:\n\n1. Navigate or create a request in Bruno.\n2. Click on the **History** feature icon (top right corner).\n\n![navigate history](/screenshots/get-started/history/navigate-history.webp)\n\n3. You will have access to the complete request activity log.\n\n![navigate history](/screenshots/get-started/history/history_log.webp)\n",
    "parentName": "get-started",
    "path": "get-started/history"
  },
  "get-started/import-export-data/export-collections": {
    "name": "export-collections",
    "content": "Exporting Collections\n\n\nIf your whole team isn't using Bruno (yet), no fear! You can export Bruno collections to other formats.\n\nOur preferred recommendation for sharing collections is using native Git versioning, but we realize there are other scenarios where exporting makes sense.\n\nBruno allows you to export as:\n\n- Bruno Collection\n- Postman Collection\n- OpenAPI Specification\n\n> _Exporting as an OpenAPI Specification is only available in our Golden and Ultimate Editions_\n\nTo export, simply hover on the Collection you'd like to export, click the `...` menu and select `Export`\n\n![ExportDialog](/screenshots/get-started/import-export/export_collection/export_collection.webp)\n\nYou can then chose the format you'd like to export to and then designate a location for the file to be saved\n\n![ExportModal](/screenshots/get-started/import-export/export_collection/export_options.webp)\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/export-collections"
  },
  "get-started/import-export-data/import-collections": {
    "name": "import-collections",
    "content": "import { Callout } from \"nextra/components\";\n\nImporting Collections\n\n\nIt's very common that users transition to Bruno from another tool, or chose to use Bruno while their colleagues may chose something else.\n\nWhatever the case, you can import the following formats as Bruno Collections:\n\n- Bruno Collection (if a Collection is manually shared with you)\n- Postman Collection\n- Postman Data Export\n- Insomnia Collection\n- Cloning a Git Repository\n- OpenAPI V3 file\n- OpenAPI V3 URL\n\n\n  **Cloning a Git Repository** is available in our Pro and Ultimate Editions.\n  Please see [Collaboration in\n  Bruno]( for more details.\n\n\n\n  **Postman Data Export** is available in our Ultimate Edition. Please see\n  [Migrating from\n  Postman](\n  for more details.\n\n\nImporting Process\n\n\nTo import a collection, either click Import Collection on the home screen of Bruno or select the ellipsis (three dots) in the top-left corner and navigate to Import Collection.\n\n> _Home screen_\n\n![Import from home screen](/screenshots/get-started/import-export/import_collection/import_collection_option.webp)\n\n> _Options menu_\n\n![Import from options menu](/screenshots/get-started/import-export/import_collection/import_collection_main_menu.webp)\n\nThen simply select the format you'd like and complete the import process.\n\n> Select your format\n\n![Select your format](/screenshots/get-started/import-export/import_collection/import_options.webp)\n\n> `Postman Data Export` has [additional steps]( in the import process.\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/import-collections"
  },
  "get-started/import-export-data/postman-migration": {
    "name": "postman-migration",
    "content": "import Image from \"next/image\";\nimport PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nMigrating from Postman\n\n\nBruno makes migrating from Postman easy. All you need to do is export your collections and environments and import them to Bruno.\n\nCollection Export\n\n\nOpen Postman and select the collection you want to migrate. Click on the `···` followed by `View more actions` to open the dropdown menu and scroll down until you find `Export`, then click on it.\n\n\n  \n  \n\n\nA popup dialog will appear, select either `Collection v2` or `Collection v2.1` format and click on the `Export` button.\n\n\n\nThe collection will be downloaded as a JSON file.\n\nNow simply follow the instructions for [Importing Collections]( and you're done!\n\nExport Data Dump\n\n\n\n  Bulk Import from Postman is included in Bruno Ultimate Edition\n\n\nYou can export a data dump of all your collections and environments in Postman. You can then import the data into any Bruno.\n\n**To [export a data dump]( do the following in Postman:**\n\n- Select the settings icon in the header, then select `Settings`.\n\n- Select the Data tab, then select `Request Data Export`.\n\n- Select `Export Data`, then select the data types you want to export. You can export collections, environments, or both.\n\n- Select `Request Data Export`.\n\n**To import your Data Dump to Bruno:**\n\n- Open the import menu and select `Postman Data Export`\n\n- Select the zip file where the export was saved\n\n- You will now see a list of all collections available for import. By default, all collections will be selected. You can chose to omit any from the import that you'd like.\n\n- Designate a location for the collections and press `import`\n\n> Although we have a translator for Postman scripts, it's always good practice to review the collections after import, especially if you are using deprecated Postman syntax in your scripts.\n\nEnvironment Export\n\n\nOpen Postman and select the environment you want to migrate. Click on the `···` to open the dropdown menu, followed by `Export` and eventually choose a location to save the environment file.\n\n\n\nNow open Bruno and open a collection by clicking on any request.\nA button in the upper right corner will appear, click on it and select `Configure`.\n\n\n\nA dialog will appear, displaying your previously exported environment file. Select the `Import` button in the bottom left corner to proceed.\nSelect `Postman Environment`, provide the environment file and that's it!\n",
    "parentName": "get-started",
    "path": "get-started/import-export-data/postman-migration"
  },
  "get-started/import-export-data/script-translator": {
    "name": "script-translator",
    "content": "import { Translator } from '../../../components/translator/translator'\nimport { AVAILABLE_THEMES } from '../../../components/translator/themes'\n\nexport default function Page() {\n  return (\n    \n      Scripts Translator\n      Welcome to the Postman to Bruno scripts translator. \\\n      This is the same function that runs behind the Import Postman Collection feature in Bruno\n      \n    \n  )\n}",
    "parentName": "get-started",
    "path": "get-started/import-export-data/script-translator"
  },
  "get-started/javascript-sandbox": {
    "name": "javascript-sandbox",
    "content": "Javascript Sandbox\n\n\nYour collections might include JavaScript code in Variables, Scripts, Tests, and Assertions. \nWe take security seriously and want to ensure you can safely interact with collections, regardless of their source or original authors. \n\nThere are two modes you can choose from:\n![Javascript Sandbox](/screenshots/javascript-sandbox.png)\n\nSafe Mode\n\nJavaScript code is executed in a secure sandbox and cannot access your filesystem or execute system commands. We recommend Safe Mode for most users.\n\n> **Note**: When in doubt, leave the Collection in Safe Mode. You can always switch to Developer Mode later.\n\nDeveloper Mode\n\nJavaScript code has access to the filesystem, can execute system commands and access sensitive information.\n\nWhen to use Developer Mode\n\n- You trust the collection source/authors (Ex: Collection maintained by you/your team) and Safe Mode is not enough for your use case.\n- You need to use external npm packages in your scripts\n- Your collection needs access to filesystem / system commands\n\nWhen to avoid Developer Mode\n\n- You are running a collection that you do not trust (Ex: Downloaded from the internet)\n\n> **Warning**: Developer Mode can be dangerous and should only be used when you fully understand the implications.\n",
    "parentName": "get-started",
    "path": "get-started/javascript-sandbox"
  },
  "get-started/variables/collection-variables": {
    "name": "collection-variables",
    "content": "Collection Variables\n\n\nCollection variables are variables that are scoped to a specific collection. They are useful for storing variables that are used across multiple requests in a collection.\n\nCreating a Collection Variable\n\n* Go to Collection Settings\n* Go to the Variables tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Collection Variables](/screenshots/variables/collection-variables.png)\n\nUsing a Collection Variable\n\nYou can use the `{{varName}}` syntax to use a collection variable in a request.\n\n![Collection Variables Usage](/screenshots/variables/collection-variables-usage.png)\n\nAccess Collection Variable inside scripts\n\nYou can also use the `bru.getCollectionVar()` function to get the value of a runtime variable and use it inside your pre request scripts.\n\n```javascript\nlet namespace = bru.getCollectionVar(\"namespace\");\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/collection-variables"
  },
  "get-started/variables/environment-variables": {
    "name": "environment-variables",
    "content": "Environment Variables\n\n\nEnvironment variables are variables that are scoped to an environment, such as local development or production. They are useful for storing variables that can be re-used across the collection that are different depending on the environment. An example would be the host url of the server you want to test.\n\nCreating an Environment Variable\n\n\n- Go to environments (top right) and press configure.\n- If there are no environments, you will be prompted to create one.\n- Add your variable name and value for the specific environment.\n- Save your changes.\n\n![Environment Variables location](/screenshots/variables/environment-variables.png)\n\n![Environment Variables Menu](/screenshots/variables/environment-variables-menu.png)\n\n\nUsing an Environment Variable\n\n\nJust like other variables you can use the `{{varName}}` syntax to use an environment variable in a request. On the top-right, you can see which environment you are currently using and select a different one.\n\nUsing the ./environment directory\n\n\nEnvironment variables are synced with the `/environments` directory inside your collection. You can also create and manage environments there.\n\nEach environment is saved in a `.bru` file, which looks like this:\n\n```bash filename=\"local.bru\"\nvars {\n  host: \n}\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/environment-variables"
  },
  "get-started/variables/folder-variables": {
    "name": "folder-variables",
    "content": "Folder Variables\n\n\nFolder variables are variables that are scoped to a specific folder. They are useful for storing variables that are used across multiple requests in a folder.\n\nCreating a Folder Variable\n\n* Go to Folder Settings (can be accessed from dropdown menu of the folder in the sidebar)\n* Go to Vars Tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Folder Variables](/screenshots/variables/folder-variables.png)\n\nUsing a Folder Variable\n\nYou can use the `{{varName}}` syntax to use a folder variable in a request.\n\n![Folder Variables Usage](/screenshots/variables/folder-variables-usage.png)\n\nAccess Folder Variable inside scripts\n\nYou can also use the `bru.getFolderVar()` function to get the value of a folder variable and use it inside your scripts.\n\n```javascript\nlet bearerToken = bru.getFolderVar(\"bearerToken\");\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/folder-variables"
  },
  "get-started/variables/global-environment-variables": {
    "name": "global-environment-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nGlobal Environment Variables\n\n\nGlobal environment variables can be used across all collections and requests. Think of them as a global store accessible throughout the app.\n\nInstead of creating the same collection variable repeatedly in each collection, you can use global variables to store common values that need to be accessed across different collections. This eliminates the repetitive task of defining the same variables every time.\n\nCreate a Global Environment Variable\n\n\n1. Go to the **Global Environments** section (top right corner) and click **Configure**.\n\n![Environment Variables location](/screenshots/variables/global-config.webp)\n\n2. Select **Create Global Environment**.\n3. (Optional) If you need to import an existing environment, you can use the **Import Environment** option.\n4. Enter a name for your environment and click **Create**.\n\n![Environment Variables location](/screenshots/variables/create-global-env.webp)\n\n5. Add a variable by specifying the **Name** and **Value**.\n\n![Environment Variables location](/screenshots/variables/sample-url.webp)\n\n6. Click **Save**.\n\nYour global environment variable is now created and can be accessed across your workspace.\n\n\n  You can click the secret checkbox to hide the values of variables while\n  hovering over them.\n\n\nUsing Global Environment Variables\n\n\nTo use a global environment variable, reference it using the format `{{var_name}}` in any request or collection. These variables can be combined with other variables and used throughout your workspace, making them ideal for consistent value sharing.\n\n![Environment Variables location](/screenshots/variables/using-global-var-example.webp)\n",
    "parentName": "get-started",
    "path": "get-started/variables/global-environment-variables"
  },
  "get-started/variables/overview": {
    "name": "overview",
    "content": "import { Callout } from \"nextra/components\";\n\nVariables\n\n\n\n  With the release of v1.28.0, we’ve shifted to treating all Request Variables\n  as strings instead of inferring the data type from the value. See\n  [discussion]( for more\n  information.\n\n\nOverview\n\n\nVariables in the Bruno allow you to store dynamic values that can be reused across multiple API requests, environments, and workflows. This feature enhances flexibility, maintainability, and efficiency by enabling you to manage frequently changing data points such as tokens, environment-specific URLs, or user-defined values in one place.\n\nTypes\n\n\nThere are 6 types of variables you can create:\n\n- [Global Environments Variables](./global-environment-variables.mdx)\n- [Environment Variables](./environment-variables.mdx)\n- [Collection Variables](./collection-variables.mdx)\n- [Folder Variables](./folder-variables.mdx)\n- [Request Variables](./request-variables.mdx)\n- [Runtime Variables](./runtime-variables.mdx)\n\nAdditionally, Process Environment Variables can be defined in an external environment configuration file:\n\n- [Process Environment Variables](./process-env.mdx)\n\nVariable Precedence\n\n\nWhen a variable is accessed, the following precedence is used to determine which value is used:\n\n1. Runtime Variables\n2. Request Variables\n3. Folder Variables\n4. Environment Variables\n5. Collection Variables\n6. Global Variables\n\nRuntime variables get the highest precedence. Process Environment Variables are accessed using the `{{process.env.VAR_NAME}}` syntax and hence don't compete with the above.\n\nVariable Data Type\n\n\nAll variables are stored as strings. Bruno does not infer or change the data type of the variable based on the value you set.\n\nScripting API\n\n\nPlease see the [Scripting API](/scripting/javascript-reference#collection-variables) for more information on how to access variables in your scripts.\n",
    "parentName": "get-started",
    "path": "get-started/variables/overview"
  },
  "get-started/variables/process-env": {
    "name": "process-env",
    "content": "import { Callout } from \"nextra/components\";\nimport { FileTree } from \"nextra/components\";\n\nProcess Environment Variables\n\n\nOverview\n\n\nProcess environment variables are used to store sensitive information, such as API keys, passwords, and other secret values. These values are typically stored in a .env file. For more details on secret management, refer to the [secret management](../../secrets-management/dotenv-file.mdx) section.\n\n\n  You must create the `.env` file in your local project directory (e.g., using\n  VS Code) to store your process environment variables. Bruno cannot create or\n  manage the `.env` file for you.\n\n\nCreating a Process Environment Variables\n\n\nTo create process environment variables, you can add a .env file to the root of your Bruno collection. This file will store your secrets, which can then be accessed throughout the collection.\n\nExample\n\n\nIn your Bruno collection, the structure might look like this:\n\n\n  \n    \n    \n      \n    \n    \n  \n  \n  \n  \n  \n\n\nIn the `.env` file, you would store a key-value pair, like this:\n\n```bash showLineNumbers filename=\".env\"\nkey = bruno\n```\n\nUsing the Process Environment Variables\n\n\nTo access the values stored in the `.env` file, you can use the `process.env` global object. For example, if you want to retrieve the key value from your `.env` file, you would use:\n\n![image](../../../../public/screenshots/variables/creating-process-env-variables.png)\n\nYou can use `process.env.` throughout your Bruno collection to securely manage and access your environment variables.\n\n![image](../../../../public/screenshots/variables/using-process-env-variables.png)\n",
    "parentName": "get-started",
    "path": "get-started/variables/process-env"
  },
  "get-started/variables/request-variables": {
    "name": "request-variables",
    "content": "Request Variables\n\n\nRequest variables are variables that are scoped to a specific request. They are useful for storing variables that is used in a specific request.\n\n> **Note**: With the release of v1.28.0, we’ve shifted to treating all Request Variables as strings instead of inferring the data type from the value. See [discussion]( for more information.\n\nCreating a Request Variable\n\n* Go to the Request \n* Go to Vars Tab\n* Add your variable name, value in the Pre Request Vars section\n* Save your changes\n\n![Request Variables](/screenshots/variables/request-variables.png)\n\nUsing a Request Variable\n\nYou can use the `{{varName}}` syntax to use a request variable in a request.\n\n![Request Variables Usage](/screenshots/variables/request-variables-usage.png)\n\nAccess Request Variable inside scripts\n\nYou can also use the `bru.getRequestVar()` function to get the value of a request variable and use it inside your scripts.\n\n```javascript\nlet source = bru.getRequestVar(\"source\");\nlet destination = bru.getRequestVar(\"destination\");\n```\n",
    "parentName": "get-started",
    "path": "get-started/variables/request-variables"
  },
  "get-started/variables/runtime-variables": {
    "name": "runtime-variables",
    "content": "import { Callout } from \"nextra/components\";\n\nRuntime Variables\n\n\nOverview\n\n\nRuntime variables are **ephemeral variables** that exist only during the runtime of the API client. These variables are scoped within a collection, meaning they are accessible to all requests within that collection. However, once the API client is closed or restarted, the values of these variables are lost. They are ideal for managing temporary data such as session tokens, dynamic parameters, or other values that are generated or updated during the execution of requests.\n\nCreating a Runtime Variable\n\n\nTo create a runtime variable, you can use the `bru.setVar(name, value)` function. This function allows you to store any value (e.g., tokens, response data, temporary user inputs) as a runtime variable.\n\nExample:\n\n\nSuppose you receive an authentication token as part of a response body and want to reuse it in subsequent requests. You can capture it using the `bru.setVar()` function in your post response script.\n\n```javascript\nbru.setVar(\"token\", res.body.token);\n```\n\nUsing a Runtime Variable\n\n\nOnce a runtime variable is created, you can use it in subsequent API requests by referencing it with the `{{variableName}}`syntax. The variable's value will be dynamically injected into the request at runtime.\n\nExample:\n\n\nIf you’ve stored a token variable using `bru.setVar()`, you can use it in headers, query parameters, body, or URL of subsequent requests like this:\n\n```plaintext\nAuthorization: Bearer {{token}}\n```\n\nYou can also use the `bru.getVar()` function to get the value of a runtime variable and use it inside your pre request scripts.\n\n```javascript\nconst token = bru.getVar(\"token\");\nreq.setHeader(\"Authorization\", `Bearer ${token}`);\n```\n\nViewing Runtime Variables\n\n\nYou can view all runtime variables by clicking on the **Eye** icon located in the top-right corner of the navigation bar\n\n\n  The request must be executed before you can view the runtime variables.\n\n\nExample:\n\nConsider the following script inside Bruno, which creates a runtime variable with a `key` and value `pair`. In this case, the key is _hey_ and the value is _Bruno_.\n\n```js\nbru.setVar(\"hey\", \"Bruno\");\n```\n\nOnce the request is executed, the runtime variable will be available for viewing. You should see something like this:\n\n![runtime-var](/screenshots/variables/runtime-var.webp)\n",
    "parentName": "get-started",
    "path": "get-started/variables/runtime-variables"
  },
  "git-integration/embed-bruno-collection": {
    "name": "embed-bruno-collection",
    "content": "import { Callout } from \"nextra/components\";\nimport { useEffect } from \"react\";\n\nFetch in Bruno Button\n\n\nBruno allows you to share your Git-synchronized collection via an embedded \"Fetch in Bruno\" (FiB) button turning the import/cloning process into a single click!\n\nThis button can be placed in websites, articles, and documentation, with support for HTML and Markdown formats.\n\nThis feature helps you to share your collections in an easy and flexible way - meeting the user wherever they are. Once imported, the user now has a Git-synced collection and can seamlessly pull down new changes as updates are made.\n\nThings You Need\n\n\n1. Bruno installed on your system.\n2. A collection that has been initialized as a Git repository [either through the UI]( or from [the CLI](\n\nHow to Share Your Collection\n\n\n1. Open Bruno.\n2. Either go to the collection Overview tab or click on the `...` and select `Share`.\n\n![collection-settings](/screenshots/git-integration/share-collection/1-share-collection-overview.webp)\n\n3. Copy the generated link (HTML or Markdown).\n\n![share-option](/screenshots/git-integration/share-collection/2-share-link-html.webp)\n\n4. Embed the link into your website, article, or documentation(e.g. GitHub Readme).\n\nexport const BrunoButton = () => (\n  \n    \n      \n    \n  \n);\n\n\n\n\nThe Fetch in Bruno button will now automatically clone the repository and associated collection whenever it is clicked.\n\nHow to Open Your Shared Collection in Bruno\n\n\n\n  Make sure you have Bruno version **1.40.0** or above installed on your system\n  to use this feature.\n\n\n1. Click on any Fetch in Bruno button.\n2. A popup will appear. Click on **Open In Bruno**.\n\n![open-in-bruno](/screenshots/git-integration/share-collection/4-fetch-in-bruno.webp)\n\n3. Choose the location where you'd like to store your collection.\n\n![collection-location](/screenshots/git-integration/share-collection/5-save-location.webp)\n\n4. You will see a list of available Bruno collections in the repository.\n\n![clone-collection](/screenshots/git-integration/share-collection/6-cloning-collection.webp)\n\nOnce the collection is loaded in Bruno, you'll be able to see the folder, requests, and all associated parameters.\n",
    "parentName": "git-integration",
    "path": "git-integration/embed-bruno-collection"
  },
  "git-integration/overview": {
    "name": "overview",
    "content": "Collaboration in Bruno\n\n\nBruno’s superpower is the ability to collaborate natively using version control systems like [Git ↗]( [CVS ↗]( etc, and platforms like GitHub, Gitlab, Bitbucket, etc. This gives you and your teammates confidence that a collection is current, and provides benefits of co-location if you choose to store collections directly alongside your source code.\n\nThe process of collaborating on a Bruno collection is more or less the same in all of the above-mentioned platforms. For beginners, you can take a look at this tutorial on version control [here ↗](\n\nThere are two ways to collaborate via native Git in Bruno:\n\n1. Using the terminal or command line to execute Git commands\n2. Using the Bruno's GUI-based Git functionality.\n   > GUI-based Git functionality is available within Pro and Ultimate Editions of Bruno.\n\nThese approaches are documented separately for ease of access. So let's dive into the next section.\n\n- [Collaboration via CLI](/git-integration/using-cli)\n- [Collaboration via GUI](/git-integration/using-gui)\n",
    "parentName": "git-integration",
    "path": "git-integration/overview"
  },
  "git-integration/using-cli": {
    "name": "using-cli",
    "content": "Collaboration via CLI\n\n\nIn the open-source version of Bruno,  Git operations are performed manually using the terminal or tools like VSCode's Git features. \n\nThis includes:\n\n- [Initializing a Git repository](#initializing-git-in-bruno-collection)\n- [Adding and committing changes](#adding-and-committing-changes)\n- [Pushing and pulling updates](#pushing-and-pulling-changes)\n\nBelow is a step-by-step guide on how to use Git with Bruno in the open-source version.\n\nInitializing Git in a Collection\n\n\nTo add your collection to version control, you need to initialize a Git repository in the directory where your .bru files are stored using the following steps:\n\n1. **Navigate to the Bruno Collection Location:**\n\n   - Navigate to the location on your PC where you created the Bruno collection, and copy the path. [^1]\n\n2. **Change directory in Terminal:**\n\n   - Run the following command in the terminal:\n\n     ```bash\n     cd path/to/your/bruno/collection\n     ```\n\n3. **Initialize Git:**\n   - Run the following command to initialize Git in the Bruno collection directory:\n\n     ```bash\n     git init\n     ```\n\nAdding and Committing Changes\n\n\nAfter initializing the Git repository, you can add and commit changes to your collection.\n\n1. **Creating a New HTTP Request in Bruno App**\n\n    - Hover over the collection name in the Bruno app.\n    - Click on the three dots, then click on \"New Request.\"\n    - Type in the name of the request and populate the URL field with `\n    - After populating the fields with appropriate values, click on the \"Create\" button, or you can press ENTER/RETURN on your keyboard to create the request. This will create a new `.bru` file with the name that you just specified.\n\n2. **Adding and committing the changes**\n   - Stage all the changes made inside the collection:\n\n     ```bash\n     git add .\n     ```\n   - Commit the changes:\n\n     ```bash\n     git commit -m \"Created my first Bruno request 🐶\"\n     ```\n\nPushing and Pulling Changes\n\n\nTo share your changes with others, you can push and pull your commits to/from a remote repository.\n\n1. **Pushing changes**\n\n   ```bash\n   git push -u origin main\n   ```\n\n2. **Pulling changes**\n\n   ```bash\n   git pull origin main\n   ```\n",
    "parentName": "git-integration",
    "path": "git-integration/using-cli"
  },
  "git-integration/using-gui/consumer": {
    "name": "consumer",
    "content": "import Video from \"@/components/Video\";\nimport PremiumBadge from \"@/components/premium-badge\";\n\n**Cloning Collections from GitHub**\n\n\nTo clone a collection from GitHub into **Bruno**, you need to have an existing collection repository hosted on GitHub.\n\n> You must have an existing collection repository hosted on GitHub.\n\nFor example, you can use this [Bruno repository]( and follow the steps below.\n\n1. Launch **Bruno** and click on the **Main Menu** in the top-left corner.\n2. Click on **Import Collection** from the dropdown menu.\n3. Select **Clone Git Repository** from the available options.\n4. Enter the above **GitHub Repository URL** and specify the **Location** where you want to save the cloned collection.\n5. Click the **Clone** button to begin cloning the repository.\n6. After the cloning process completes, select the **Collection** you want to open and click **Open**.\n\nYou'll see your collection will be open in **Bruno**.\n\n\n\n**Pulling Changes**\n\n\nPull the latest changes from the remote repository to stay synchronized with your team.\n\n1. Click on **main** from navbar and Select **Pull** from dropdown.\n2. Confirm the **Remote Server** configurations.\n3. Click on **Pull** button.\n\nNow you can see all your remote changes pulled in your collection.\n\n\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui/consumer"
  },
  "git-integration/using-gui/intro": {
    "name": "intro",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\n**Collaboration via GUI** \n\n\nBruno offers an intuitive **GUI-based Git collaboration** feature, available in the [Pro]( and [Ultimate Editions]( This feature makes it easier for both engineering and non-engineering teams to collaborate seamlessly on collections.\n\n\n  Git must be\n  [installed]( on\n  your machine to use this feature.\n\n\nThis feature includes following actions:\n\n- [Initializing Git in a Collection](../using-gui/provider#initializing-git)\n- [Adding and Committing Changes](../using-gui/provider#adding-and-committing-changes)\n- [Pushing and Pulling Changes](../using-gui/provider#pushing-and-pulling-changes)\n- [Branch Creation and Checkout](../using-gui/provider#branch-creation-and-checkout)\n- [Cloning a Repository](./consumer#cloning-collections-from-github)\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui/intro"
  },
  "git-integration/using-gui/provider": {
    "name": "provider",
    "content": "import Video from \"@/components/Video\";\n\n**Initializing Git**\n\n\nInitializing Git in Bruno is the first step towards managing your API collections with version control. It’s easy and quick to set up. Follow the steps below to initialize Git.\n\n1. Launch the **Bruno app**.\n2. Navigate to the collection you want to initialize with Git.\n3. Click on the **Git Icon** in the top-right corner of the navbar.\n4. Click the **Initialize** button to set up your collection with Git.\n\nThis allows you to perform other Git operations such as adding, committing, pushing, pulling changes, and more.\n\n\n\n**Connecting to Remote Repository**\n\n\nOnce you have initialized your collection, the next step is to connect it to a remote Git repository.\nYou can directly connect to remote repository from Bruno using Git GUI feature.\n\nTo connect Bruno to GitHub, you need to set up either an SSH key or a Personal Access Token (PAT) on GitHub. Follow this [official GitHub guide]( to set it up.\n\n1. Create empty Git repository on your GtiHub.\n2. Open **Git initialized** Bruno collection.\n3. Click on **main** (top right corner).\n4. Select **Remotes** from the dropdown.\n\n![remotes](/screenshots/git-integration/git-gui/git-remote-option.webp)\n\n5. Click on **Add Remote** button.\n\n![remotes](/screenshots/git-integration/git-gui/add-remote.webp)\n\n6. Enter **Remote Name** and **URL** (Https or SSH) and click on save.\n\n![remotes](/screenshots/git-integration/git-gui/add-remote-url.webp)\n\n\nAfter completing the above steps, your collection will be connected to GitHub. We have to **add and commit** (see below) some changes to pushed collection to GitHub.\n\n\nOnce your collection is connected to the remote repository, you can manage it directly from the Bruno app.\n\n**Adding and Committing Changes**\n\n\nOnce you’ve made changes to your collection in Bruno, you can easily commit those changes using the Git UI. This allows you to track changes and collaborate with your team efficiently.\n\nFollow these steps to add and commit changes:\n\n1. Open the collection you've initialized with Git and access the **Git UI** from the **main** dropdown in the top-right corner.\n2. Go to the **Changes Tab**.\n3. Click on **Add Icon** for the changes you want to commit.\n4. Click on **Commit Changes** button.\n5. Write a Commit Message and click **Commit**.\n\n> You can commit all changes in a single click by pressing the **Add All Changes** button.\n\nBy following these steps, your changes are now committed and tracked in Git, ready to be pushed or shared with others.\n\n\n\n**Pushing and Pulling Changes**\n\n\nThe GUI-based Git integration in Bruno allows both engineering and non-engineering teams to work together in a fast, efficient, and accurate manner. This integration ensures that your collections remain consistently up-to-date across all team members.\n\n> Before you can push or pull changes, ensure that the **remote repository** is linked to your project.\n\n**Pushing Changes**\n\n\nPush your local changes to the remote repository with just a few clicks.\n\n1. Click on **main** from top-right corner and select **Push** from drop-down.\n2. Confirm the **Remote Server** configurations.\n3. Click on **Push** button.\n\nNow you can see all your local changes pushed to the remote repository.\n\n\n\n> Follow Consumer guide to learn about pulling changes feature.\n\n**Branch Creation and Checkout**\n\n\nWith branches in **Bruno**, you can manage your code effectively by isolating different features or tasks.\n\nCreating Branches\n\n\nFollow the below steps to create branches in Bruno.\n\n1. Navigate to the **Collection** in Bruno.\n\n2. Click on the **main** from the top-right and select **Create New Branch** from dropdown.\n\n3. Enter **Branch Name**.\n\n4. Click on **Save** button.\n\nOnce the branch is created, you can start making changes to the branch.\n\nBranch Checkout\n\n\n1. Click on **Checkout Branch** from **main**.\n2. Select the branch you want to switch from **Local** or **Remote**.\n3. Click on **Checkout** button.\n4. Now you're switched to your selected branch.\n\n\n",
    "parentName": "git-integration",
    "path": "git-integration/using-gui/provider"
  },
  "introduction/feedback-community": {
    "name": "feedback-community",
    "content": "Feedback & Community\n\n\nBruno is building a community of API practitioners who want to challenge the state of tooling available. Our roadmap and releases are driven by your feedback and, as an open-source project, sometimes directly from your PRs.\n\nHelp us continue building the most powerful, logical, and dev-friendly API tool available today!\n\nHow to Engage\n\n\n- Raise a [GitHub Issue](\n- Star us on [Github](\n- Join our [Discord](\n- Email our [Support Team](mailto:support@usebruno.com)\n",
    "parentName": "introduction",
    "path": "introduction/feedback-community"
  },
  "introduction/manifesto": {
    "name": "manifesto",
    "content": "Manifesto\n\n\nIt's time for a revolution in API client technology! \n\nWe refuse to be shoehorned into a proprietary version control system for collaborating on API collections and we don't want the details of our APIs, API requests, or API responses synced to the cloud and potentially be made public. \n\nWe are an opensource project, rising up against the monopoly of bloated and closed systems. We believe that API collections should be co-located within your source code repository, serving as a living set of examples on how to use the API.\n\nWith Bruno, collections become first-class citizens, co-located with related information and easily version controlled. We say goodbye to bloated workspaces and global environments, and embrace the benefits of co-location.\n\nWe dream of a world where developers can clone a code repo, get it up and running, use Bruno to browse the examples on how to use the API and start playing with it. No more horror stories of *\"Tim had the collections for the payment-api service, but he left the company last month.\"*\n\nJoin us in our mission to create a better API client for developers. Say goodbye to bloatware and hello to simplicity, efficiency and freedom. Try Bruno today and experience the difference for yourself.\n",
    "parentName": "introduction",
    "path": "introduction/manifesto"
  },
  "introduction/what-is-bruno": {
    "name": "what-is-bruno",
    "content": "What is Bruno? \n\n\nBruno is a Git-friendly and offline-first open-source API client aimed at revolutionizing the status quo represented by tools like Postman and Insomnia. \n\nWe aim to solve two core issues: \n\n**Collaboration**\n\n\nBruno’s superpower is collaboration through a live connection to your version control system, such as Git. \n\nWith Bruno, collections are stored directly in a folder on the filesystem. A plain text markup language, Bru, is used to save information about API requests. \n\n> *Go to documentation for [Collaboration via Git](../git-integration/overview)*\n\n**Data Privacy and Security**\n\n\nLegacy API clients have moved towards capturing every piece of data they can, from your PII (name, email), to the actual contents of your API requests and responses (keys, tokens, etc).\n\nBruno is an offline tool. There's no concept of a login or account, and there is no cloud connection or syncing of the work you do in Bruno. \n\n\n\n>\n> - *If you or your organization purchases a Golden Edition license, your email is required simply for the issuance of a license key.* \n> - *If your organization purchases an Ultimate Edition license, your email can be held in a self-hosted licensing server which you manage.*\n>\n",
    "parentName": "introduction",
    "path": "introduction/what-is-bruno"
  },
  "license-management/end-users/activate-license": {
    "name": "activate-license",
    "content": "Activating Your License\n\n\n> You must be on Bruno v.1.35.0 or higher to activate a license after December 1, 2024\n\nIf you've been provisioned a license, you should have received a license key via email. If you have not received a key and already checked your spam folder, please reach out to your license administrator.\n\nStep 1: Click on the Settings or Key icon in Bruno\n\n\nBoth icons are located at the bottom left corner of the Bruno window. The Key icon will take you directly to the `License` section. If you choose to use the Settings icon, simply select `License` from the settings menu. \n\nStep 2: Enter License Details \n\n\nEnter your license key and associated email address\n\n![login](/screenshots/license-management/activatelicense.webp)\n\n> If your company uses a self-hosted licensing server, select `License Server` and enter the details provided to you by your License Administrator. \n\nStep 4: License Activated\n\n\nOnce the license is activated, you will see a success message.\n",
    "parentName": "license-management",
    "path": "license-management/end-users/activate-license"
  },
  "license-management/license-administrators/license-portal": {
    "name": "license-portal",
    "content": "import Image from 'next/image'\n\nLicense Management Portal\n\n\nBruno provides a licensing management portal for the purposes of:\n\n- Provisioning and deprovisioning licenses\n- Managing License Administrators associated with your account\n- Viewing details related to your Bruno subscription\n\nAccessing the Portal\n\n\nIf you've been designated as a License Administrator, either through purchasing on our website or through assignment by another admin:\n\n- Navigate to  \n\n\n\n- Enter your email address and press `continue`\n- Retrieve and enter the OTP (one time password) that was sent to your email\n\n\n\n- You have now accessed the portal! \n\nAssigning licenses\n\n\nAdding a single user\n\n\n- Select `Add User`\n- Enter the name and email of the user you'd like to add\n- Click `Create`\n\n\n\n- The user will automatically receive an email with their license key\n\nAdding users in bulk\n\n\n> Ultimate licenses come with the ability to add users via a CSV upload\n\n- Select `Upload Users`\n- *optionally download the sample CSV to view the format for user upload*\n- Click `Upload`and select your file\n- Click `Add Users`\n\n\n\n- Users will automatically receive an email with their respective license key\n\nRemoving licenses \n\n\n- Click on the trash can icon in the user's row\n- Select `Delete`\n\n\nAdding License Administrators\n\n\nThe number of Licenses Administrators you can have associated with your account is based on your [plan type]( \n\n- Navigate to `Settings`\n- Click on `Admins` page\n\n\n\n- Select `Add Admin`\n\n\n\n- Enter their name and email\n- Select `Add`\n\nView Plan Details\n\n\nYou can view the type of plan, number of licenses, and subscription dates by:\n\n- Navigate to `Settings`\n- Select `Billing`\n\n\n",
    "parentName": "license-management",
    "path": "license-management/license-administrators/license-portal"
  },
  "license-management/overview": {
    "name": "overview",
    "content": "Overview\n\n\nFor our open-source users, there is no concept of license management! Simply download, install, and go! \n\nOur commercial plans have different license management aspects. \nIf you have any questions about what plan is best suited for you, please see our [pricing page]( or [contact us](mailto:sales@usebruno.com) to discuss. \n\nLicense Management \n\n\nFor License Administrators \n\n- [License Portal](/license-management/license-administrators/license-portal)\n\nFor Users \n\n- [Activate License](/license-management/end-users/activate-license)",
    "parentName": "license-management",
    "path": "license-management/overview"
  },
  "open-api/overview": {
    "name": "overview",
    "content": "import Image from \"next/image\";\nimport PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nOpenAPI and Bruno\n\n\nBruno allows you to work with OpenAPI Specification (OAS) files in a number of ways:\n\n- Creating a collection from an OAS file import\n- Exporting a collection as an OAS file \n- Viewing and Designing an OAS file \n\nCreating a Collection from OAS Import\n\n\nBruno supports importing OAS V3 files only\n\n- Select Import\n- Choose OpenAPI V3 File\n\n![select-openapi-file](/screenshots/open-api/select-open-api.webp)\n\n- Select the file stored on your machine\n\nExporting a Collection as an OAS File \n\n\n- Right-click on a collection and select Export\n\n![select-export](/screenshots/open-api/select-export.webp)\n\n- Choose OpenAPI Specification\n\n![select-openapi-from-export-menu](/screenshots/open-api/select-open-api-menu.webp)\n\n- Name your file and designate a location for it to be stored\n\n![export-open-api](/screenshots/open-api/export-api-spec.webp)\n\nViewing and Designing an OAS file \n\n\nIf you've saved or otherwise have an OAS file on your machine, you can view the OAS in a SwaggerUI-esque manner by:\n\n- Selecting Open API Spec\n\n![open-open-api](/screenshots/open-api/open-api-spec.webp)\n\n- Choose the file name and location that you want to open\n\nThis will then open the spec in a separate section of your Bruno sidebar called APIs.\n\nIf you want to create an OAS file, you can:\n\n- Select Create API Spec\n  ![create-open-api](/screenshots/open-api/create-api-spec.webp)\n\n- Designate whether you want to create a Blank Spec, or generate it from an existing Bruno Collection\n\n![location-open-api](/screenshots/open-api/select-api-spec-location.webp)\n\n- Choose a name and location for the spec to be saved under.\n\nYou will now have the scaffolding of an OAS that you can continue to design.\n\n![location-open-api](/screenshots/open-api/write-api-spec.webp)\n",
    "parentName": "open-api",
    "path": "open-api/overview"
  },
  "secrets-management/aws-secrets-manager/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHow to Add a Secret Provider\n\n\nSetting Up AWS Secret Manger as a Secret Provider\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo configure AWS Secrets Manager as a secret provider in Bruno:\n\n\n1. Navigate to the application settings, located at the bottom of the left sidebar, and go to the Secrets Manager section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Choose **AWS Secrets Manager** as the provider type.\n\n5. Provide the required credentials, including `Access Key ID`, `Secret Access Key` and `Region`\n\n6. Use the `Test Provider` feature to verify your connection.\n\n6. Click `Add` to save the secret provider configuration.\n\n\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/aws-secrets-manager/adding-a-secret-provider"
  },
  "secrets-management/aws-secrets-manager/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nConfiguring and Fetching secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n> Secrets in Bruno are environment-specific, so ensure you have a collection environment selected before proceeding.\n\n1. Go to **Collection Settings** and navigate to the **Secrets** section.\n\n2. Select `AWS Secrets Manager` as the provider.\n\n3. Choose an environment if not already selected. (Secrets are environment-specific)\n\n4. Add a new secret by clicking on the `+ Add Secret` button.\n\n5. Provide a name for the secret and specify specify the AWS secret name or ARN.\n\n6. Click on the `Fetch Secrets` button on the top left corner, choose one of the accounts, and click on the `Fetch` button.\n\n7. The fetched secrets will be displayed in the table along with their names.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/aws-secrets-manager/configuring-and-fetching-secrets"
  },
  "secrets-management/aws-secrets-manager/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\n\nAWS Secret Manager\n\n\n\n\nAWS Secret Manager integration is available via an Experimental Build. You can download it [here](\n\n\n\nAWS Secrets Manager is a secure and scalable service designed to store and retrieve sensitive information such as API keys, database credentials, and other secrets. \n\nBruno allows you to easily integrate with AWS Secrets Manager and securely access secrets during test execution without exposing them in test scripts or environment variables. \n\nThis guide provides detailed steps to configure and utilize AWS Secrets Manager in Bruno.\n\n- [Adding a secret provider](/secrets-management/aws-secrets-manager/adding-a-secret-provider)\n- [Configuring and fetching secrets](/secrets-management/aws-secrets-manager/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)",
    "parentName": "secrets-management",
    "path": "secrets-management/aws-secrets-manager/overview"
  },
  "secrets-management/aws-secrets-manager/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nSecrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\n\n\nSecrets need to be prefixed with `$secrets` followed by the `name` and then the `key name`, all separated by periods.\n\n\n\nPattern: `$secrets`.``.``.\n\nExample:\nIf you have a secret named `dbCredentials` with a key `username`, you can reference it as:\n`$secrets.dbCredentials.username`\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/aws-secrets-manager/using-secrets"
  },
  "secrets-management/azure-key-vault/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHow to Add a Secret Provider\n\n\nSetting Up Azure Key Vault as a Secret Provider\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo configure Azure Key Vault as a secret provider in Bruno:\n\n\n1. Navigate to the application settings, located at the bottom of the left sidebar, and go to the Secrets Manager section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Choose **Azure Key Vault** as the provider type.\n\n5. Provide the required credentials, including `Tenant ID`, `Client ID` and `Client Secret`\n\n6. Use the `Test Provider` feature to verify your connection.\n\n6. Click `Add` to save the secret provider configuration.\n\n\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/azure-key-vault/adding-a-secret-provider"
  },
  "secrets-management/azure-key-vault/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nConfiguring and Fetching secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n> Secrets in Bruno are environment-specific, so ensure you have a collection environment selected before proceeding.\n\n\n1. Go to **Collection Settings** and navigate to the **Secrets** section.\n\n2. Select `Azure vault` as the provider.\n\n3. Choose an environment if not already selected. (Secrets are environment-specific)\n\n4. Add a new secret by clicking on the `+ Add Secret` button.\n\n5. Provide a name for the secret and specify the Vault name.\n\n6. Click on the `Fetch Secrets` button on the top left corner, choose one of the accounts, and click on the `Fetch` button.\n\n7. The fetched secrets will be displayed in the table along with their names.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/azure-key-vault/configuring-and-fetching-secrets"
  },
  "secrets-management/azure-key-vault/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\n\nAzure Key Vault\n\n\n\n\nAzure Key Vault integration is available via an Experimental Build. You can download it [here](\n\n\n\nAzure Key Vault is a secure and scalable service designed to store and retrieve sensitive information such as API keys, database credentials, and other secrets. \n\nBruno allows you to easily integrate with Azure Key Vault and securely access secrets during test execution without exposing them in test scripts or environment variables. \n\nThis guide provides detailed steps to configure and utilize Azure Key Vault in Bruno.\n\n- [Adding a secret provider](/secrets-management/azure-key-vault/adding-a-secret-provider)\n- [Configuring and fetching secrets](/secrets-management/azure-key-vault/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/azure-key-vault/overview"
  },
  "secrets-management/azure-key-vault/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nSecrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\n\n\nSecrets need to be prefixed with `$secrets` followed by the `name` and then the `key name`, all separated by periods.\n\n\n\nPattern: `$secrets`.``.``.\n\nExample:\nIf you have a secret named `dbCredentials` with a key `username`, you can reference it as:\n`$secrets.dbCredentials.username`\n\n",
    "parentName": "secrets-management",
    "path": "secrets-management/azure-key-vault/using-secrets"
  },
  "secrets-management/dotenv-file": {
    "name": "dotenv-file",
    "content": "import { FileTree } from \"nextra/components\";\n\nSecrets Management\n\n\nDotEnv File\n\n\nEnvironment variables are used to store sensitive data such as API keys, tokens, and configuration settings outside the source code. This helps keep your code secure and makes it easier to manage different settings for various environments (e.g., local, staging, production).\nIn **Bruno**, environment variables can be managed through `.env` files.\n\nDotEnv File for Secret Management\n\n\nIn **Bruno**, you can store your secrets (e.g., API keys, JWT tokens) in a `.env` file located at the **root** of your collection folder. This approach is inspired by how developers typically manage secrets in their codebase.\n\nYou **cannot** create the `.env` file directly inside Bruno. You need to manually create the `.env` file at the **root** of your Bruno collection folder to store your secrets. Once created, you can access those variables within your Bruno collection.\n\nFolder Structure Example\n\n\nBelow is an example folder structure for your collection:\n\n\n  \n    \n    \n      \n    \n    \n  \n  \n  \n  \n  \n\n\nCreating and Using the `.env` File\n\n\n1. Create a `.env` file manually in the root of your collection folder. This file will store your sensitive environment variables.\n\n2. Define your secrets in the `.env` file. For example:\n\n```bash filename=\".env\" showLineNumbers\nJWT_TOKEN=your_jwt_token_value\nAPI_KEY=your_api_key_value\n```\n\nThese secrets will be accessible in your Bruno collection via the `process.env` object.\n\n![dot env vars](/screenshots/dot-env-vars.webp)\n\nBruno will automatically load the secrets from this file and make them available to your collection via `process.env.`.\n\nYour environment file at `environments/local.bru` would look like\n\n```bash filename=\"local.bru\"\nvars {\n  baseURL: \n  JWT_TOKEN: {{process.env.JWT_TOKEN}}\n  API_KEY: {{process.env.API_KEY}}\n}\n\n```\n\nIn this example, the `JWT_TOKEN` secret from the `.env` file is referenced using `process.env.JWT_TOKEN`. This will be replaced with the actual value of `JWT_TOKEN` when the collection is executed.\n\nManaging Secrets\n\n\n1. Always add the `.env` file to your `.gitignore` file to ensure secrets are not accidentally pushed to version control.\n\n2. If you need to share the structure of your environment variables with other developers, create a `.env.sample` file without actual secret values.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/dotenv-file"
  },
  "secrets-management/hashicorp-vault/adding-a-secret-provider": {
    "name": "adding-a-secret-provider",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHow to Add a Secret Provider\n\n\nYou have the option to integrate [HashiCorp Cloud Vault]( [Vault Enterprise Server]( or a [Local Vault server]( as your secret provider.\n\nSetting Up Vault Server\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo configure a **Vault server** secret provider, you can opt for either **Token** or **AppRole** authentication.\n\n1. Go to the application settings located at the bottom of the left sidebar and navigate to the **Secrets** section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Choose **Vault Server** as the provider type and select your preferred authentication method.\n\n4. Enter ` if using a local server, or the URL of the hosted server (e.g., `\n\n5. Provide the necessary [Token]( or [AppRole]( credentials.\n\n6. Click on **Add** to save the secret provider.\n\n\n\n\nSetting up Vault Cloud\n\n\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nTo set up a **Vault Cloud** secret provider, follow these steps:\n\n1. Go to the application settings located at the bottom of the left sidebar and navigate to the **Secrets** section.\n\n2. Click on the `+ Add Secret Provider` button.\n\n3. Select **Vault Cloud** as the provider type.\n\n4. Maintain the default settings for `Token Endpoint` and `Secrets Endpoint`, or modify them if necessary.\n\n5. Provide the required [Client Credentials](\n\n6. Add one or more Projects (Apps) to the secret provider.\n\n7. Click on **Add** to save the secret provider.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/adding-a-secret-provider"
  },
  "secrets-management/hashicorp-vault/configuring-and-fetching-secrets": {
    "name": "configuring-and-fetching-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nConfiguring and Fetching secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\n1. Go to **Collection Settings** and navigate to the **Secrets** section.\n\n2. Select `Vault` as the provider.\n\n3. Choose an environment if not already selected. (Secrets are environment-specific)\n\n4. Add a new secret by clicking on the `+ Add Secret` button.\n\n5. Provide a name for the secret and specify the relative path to where the secret is stored in Vault.\n\n6. Click on the `Fetch Secrets` button on the top left corner, choose one of the secret providers, and click on the `Fetch` button.\n\n7. The fetched secrets will be displayed in the table along with their names and paths.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/configuring-and-fetching-secrets"
  },
  "secrets-management/hashicorp-vault/overview": {
    "name": "overview",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nHashiCorp Vault\n\n\nHashiCorp Vault is a tool for managing secrets and protecting sensitive data. It is designed to provide a secure, reliable, and scalable solution for managing secrets such as API keys, passwords, certificates, and other sensitive data. Vault provides a centralized platform for storing and accessing secrets, and includes features such as encryption, access control, auditing, and more.\n\nBruno allows you to easily integrate Hashicorp Vault and access your secrets securely. With Bruno, you can securely store your Vault credentials and access them without exposing sensitive information.\n\nIn this guide, we will show you how to set up HashiCorp Vault with Bruno.\n\n- [Adding a secret provider](/secrets-management/hashicorp-vault/adding-a-secret-provider)\n- [Configuring and fetching secrets](/secrets-management/hashicorp-vault/configuring-and-fetching-secrets)\n- [Using secrets in Bruno](./using-secrets)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/overview"
  },
  "secrets-management/hashicorp-vault/using-secrets": {
    "name": "using-secrets",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing secrets\n\n\n\n  \n  Your browser does not support the video tag.\n\n\n\n\nSecrets are accessed in the same way as collection and environment variables. The secrets can be accessed in headers, query, body, auth input fields similar to collection and environment variables.\n\n\n\nSecrets need to be prefixed with `$secrets` followed by the `secret name` and then the `key name`, all separated by periods.\n\n\n\nPattern: `$secrets`.``.``.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/using-secrets"
  },
  "secrets-management/hashicorp-vault/using-with-cli": {
    "name": "using-with-cli",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nUsing with Bruno CLI\n\nPre-requisites\n\n\nAdd the vault connection configuration to the collection's **secrets.json** file (create one if it doesn't exist).\nYou can use environment variables in the configuration to avoid hardcoding sensitive information.\n\nThis is the only additional configuration required to use the vault secrets in the collection using the CLI.\n\n\nUsage\n\n\nThere are 3 different CLI configurations that can be used.\n\nVault server with token authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-server\",\n    \"vaultServerConfig\": {\n      \"url\": \"\n      \"namespace\": \"bruno\",\n      \"auth\": {\n        \"method\": \"token\",\n        \"token\": \"{{authToken}}\"\n      }\n    }\n  },\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var authToken=your-vault-token\n```\n\n\nVault server with appRole authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-server\",\n    \"vaultServerConfig\": {\n      \"url\": \"\n      \"namespace\": \"bruno\",\n      \"auth\": {\n        \"method\": \"app_role\",\n        \"appRole\": {\n          \"role\": \"bruno\",\n          \"roleId\": \"{{roleId}}\",\n          \"secretId\": \"{{secretId}}\"\n        }\n      }\n    }\n  }\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var roleId=your-role-id --env-var secretId=your-secret-id\n```\n\n\nVault cloud with client credentials authentication\n\n\n```json filename=\"secrets.json\"\n{\n  \"type\": \"vault\",\n  \"cli\": {\n    \"type\": \"vault-cloud\",\n    \"vaultCloudConfig\": {\n      \"auth\": {\n        \"method\": \"client-credentials\",\n        \"clientCredentials\": {\n          \"tokenEndpoint\": \"{{tokenEndpoint}}\",\n          \"secretsEndPoint\": \"{{secretsEndpoint}}\",\n          \"clientId\": \"{{clientId}}\",\n          \"clientSecret\": \"{{clientSecret}}\"\n        }\n      },\n      \"project\": {\n        \"name\": \"{{projectName}}\",\n        \"projectId\": \"{{projectId}}\",\n        \"organizationId\": \"{{organizationId}}\"\n      }\n    }\n  },\n  \"data\": [\n    {\n      \"environment\": \"Prod\",\n      \"secrets\": [\n        {\n          \"name\": \"db\",\n          \"path\": \"secret/db\",\n          \"enabled\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\nCorresponding CLI command:\n\n```bash copy\nbru run folder --env Prod --env-var tokenEndpoint=your-token-endpoint --env-var secretsEndpoint=your-secrets-endpoint --env-var clientId=your-client-id --env-var clientSecret=your-client-secret --env-var projectName=your-project-name --env-var projectId=your-project-id --env-var organizationId=your-organization-id\n```\n",
    "parentName": "secrets-management",
    "path": "secrets-management/hashicorp-vault/using-with-cli"
  },
  "secrets-management/overview": {
    "name": "overview",
    "content": "Secrets Management\n\n\nProblem Statement\n\n\nIn any collection, there are secrets that need to be managed. These secrets can be anything such as API keys, passwords, or tokens.\n\nA common practice is to store these secrets in environment variables.\n\nThere are two ways in which developers share bruno collections:\n* Check in the collection folder to source control (like git)\n* Export the collection to a file and share it\n\nIn both these cases we want to ensure that the secrets are stripped out of the collection before it is shared.\n\nSolution\n\n\nBruno offers two approaches to manage secrets in collections.\n\n- [DotEnv File](/secrets-management/dotenv-file)\n- [Secret Variables](/secrets-management/secret-variables)\n",
    "parentName": "secrets-management",
    "path": "secrets-management/overview"
  },
  "secrets-management/secret-variables": {
    "name": "secret-variables",
    "content": "Secrets Management\n\n\nSecret Variables\n\n\nIn this approach, you can check the `secret` checkbox for any variable in your environment.\n\nBruno will manage your secrets internally and will not write them into the environment file.\n\n![secret variables](/screenshots/secret-variables.webp)\n\nYour environment file at `environments/local.bru` would look like\n```bash filename=\"local.bru\"\nvars {\n  host: \n}\nvars:secret [\n  jwtToken\n]\n\n```\n\nAnd now you can safely check in your collection to source control without worrying about exposing your secrets.\n\nWhen you export your collection as a file, Bruno will not export the secret variables.\n",
    "parentName": "secrets-management",
    "path": "secrets-management/secret-variables"
  },
  "send-requests/REST/body-data": {
    "name": "body-data",
    "content": "Body Data\n\n\nThe **Body** tab in Bruno allows you to send specific data with your API requests. You can choose from various data formats, such as Form, Raw, and others, using the dropdown menu.\n\nSend Body Data with API Requests\n\n\nYou can select the data type based on your API request requirements. For example, if you're working with a request where you need to send specific details about a particular item, you’ll likely choose JSON as the data type and include the data in the body of the request.\n\nForm-Data\n\n\n1. Multipart Form\n\n\nUsed for sending files along with form data, allowing multiple parts with different content types in a single request. In multipart form data, each part of the request is separated by a boundary.\n\n1. Navigate to the **Body** tab.\n2. Select **Multipart Form** from dropdown.\n3. Click on **Add File** and upload your file.\n4. (optional) You can also select **Add Param** for sending key-value pair data.\n5. Save and execute the request.\n\n![multipart-data](/screenshots/send-request/multipart-data.webp)\n\n2. URL Encoded\n\n\nIt is commonly used for simple form submissions where data is sent as key-value pairs. Each key and value are separated by an equal sign (=), and multiple pairs are separated by an ampersand (&).\n\n1. Navigate to the **Body** tab.\n2. Select **Form URL Encoded** from dropdown.\n3. Click on **Add Param** and add key-value pair.\n4. Save and execute the request.\n\n![url-encoded](/screenshots/send-request/url-encoded.webp)\n\nRaw Data\n\n\nRaw Data allows you to send data in its raw, unprocessed form in the body of an API request. It doesn’t require a predefined structure like key-value pairs or multi-part boundaries. Instead, you can send data exactly as it is, which is useful when dealing with structured data formats such as **JSON, XML, Sparql or plain text**.\n\n1. Navigate to the **Body** tab.\n2. In the RAW section, select your preferred data format.\n3. Add appropriate data for your API request.\n4. Save and execute the request.\n\n![raw-data](/screenshots/send-request/raw-data.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/body-data"
  },
  "send-requests/REST/code-generator": {
    "name": "code-generator",
    "content": "Code Generator\n\n\nBruno makes it easy to generate code snippets from your API requests, allowing you to quickly integrate and test your API in various programming languages. This feature supports multiple languages (35+) and can help you save time when writing client code for your API.\n\nHow Code Snippets Work in Bruno\n\n\nBruno’s Code Snippet feature automatically generates the necessary code to make the same API request in various programming languages, such as **Python, JavaScript, cURL,** and others. This makes it easy to share and implement API calls directly into your application.\n\nSteps to Generate Code Snippets in Bruno\n\n\n1. Create or Open an API request.\n2. Go to the **Generate Code** Section (next to the request).\n\n![generate-code-pop-up](/screenshots/send-request/generate-code-pop-up.webp)\n\n3. Select your desired programming language from the dropdown to generate the code snippet.\n\n![generate-code-options](/screenshots/send-request/generate-code-options.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/code-generator"
  },
  "send-requests/REST/overview": {
    "name": "overview",
    "content": "Overview\n\n\nA REST API (Representational State Transfer) is a popular architectural style for designing APIs and web services. It enables communication between client and server through standard HTTP methods such as GET, POST, PUT, DELETE, and PATCH to transfer data.\n\nREST APIs are stateless, meaning the server does not store any information about the client between requests. This stateless nature makes REST APIs easier to maintain and scale.\n\nHTTP Methods\n\n\n| HTTP Method          | Usage                                      |\n| -------------------- | ------------------------------------------ |\n| `GET /users`         | Retrieve a list of users.                  |\n| `POST/users`         | Create a new user.                         |\n| `PUT /users/{id}`    | Update the information of a specific user. |\n| `DELETE /users/{id}` | Delete a user.                             |\n\nHTTP Status Codes\n\n\nHTTP status codes are issued by a server in response to a client's request made to the server. They provide information about the outcome of the request. Here's a table of some common HTTP status codes and their descriptions:\n\n| **Status Code** | **Description** |\n| --------------- | --------------- |\n| 100             | Informational   |\n| 200             | Successful      |\n| 300             | Redirection     |\n| 400             | Client Error    |\n| 500             | Server Error    |\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/overview"
  },
  "send-requests/REST/parameters": {
    "name": "parameters",
    "content": "Parameters\n\n\nBruno enables you to send data with your HTTP requests. You can include both query and path parameters in the request and define their corresponding values.\n\n1. [Query Parameters](#query-parameters)\n2. [Path Parameters](#path-parameters)\n\nQuery Parameters\n\n\nQuery parameters are a way to pass additional information to a server via the URL when making an HTTP request. They are commonly used in GET requests to filter, sort, or specify the data you're asking for.\n\nHow Query Parameters Work\n\n\n1. Query parameters are appended to the end of the URL after a `?` symbol.\n2. Each parameter consists of a **key-value** pair.\n3. If there are multiple query parameters, they are separated by an `&` symbol.\n\nCreate Query Parameters in Bruno\n\n\n1. Create request inside collection.\n2. Navigate to the **Params** tab.\n3. Enter the **Name** of the parameter and its corresponding **Value**.\n\n![create-query-params](/screenshots/send-request/query-params.webp)\n\nYou’ll notice that the values are appended to the URL, starting with a `?`.\nYou can choose which parameters to include or exclude by clicking the checkbox next to each one.\n\nPath Parameters\n\n\nA path parameter is a dynamic value embedded directly in the URL path of an API request. It is used to specify particular resources or data points within an API endpoint.\n\nHow Path Parameters Work\n\n\n1. Path parameters are embedded directly in the URL path.\n2. They are represented as placeholders preceded by a colon (:).\n3. When making the request, the placeholder is replaced with a dynamic value, which is part of the URL.\n\n**Example**:\n\n```bash\n\n```\n\n`:id` is a path parameter.\n\nCreate Path Parameters in Bruno\n\n\n1. Create request inside collection.\n2. Navigate to the **Params** tab.\n3. Add the path parameter variable in the URL. e.g. `/users/:user`\n4. Enter the value in the **path parameter** section for the corresponding variable.\n5. Save and execute the request.\n\n![path-params](/screenshots/send-request/path-param.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/parameters"
  },
  "send-requests/REST/req-header": {
    "name": "req-header",
    "content": "import { Callout } from 'nextra/components'\n \nRequest headers\n\n\nRequest headers are **key-value** pairs sent along with an HTTP request to provide additional information to the server about the request. The request headers give the server more information about how to process the incoming request.\n\n**Default Headers**: Default headers are predefined headers that are part of the HTTP specification.\n\n**Custom Headers**: Custom headers are headers that are **user-defined** and are not part of the official HTTP specification.\n\nCreate request headers in Bruno\n\n\n1. Create request inside collection.\n2. Navigate to the **Headers** tab.\n3. Enter the **Name** of the parameter and its corresponding **Value**.\n4. Save and execute the request.\n\n![req-headers](/screenshots/send-request/req-headers.webp)\n\n\n  To view default headers, navigate to the **Headers** tab in your request. For\n  custom headers, check the **Timeline** tab.\n\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/req-header"
  },
  "send-requests/REST/rest-api": {
    "name": "rest-api",
    "content": "REST API request\n\n\nBruno enables you to send API requests using both HTTP and GraphQL protocols. You can include various details in the request, such as parameters, body, headers, and more, based on the API specifications.\nYou can select multiple HTTP methods such as `GET` and `POST` while working with HTTP protocol.\n\nCreate new request\n\n\n1. Create new request inside collection.\n2. Select **HTTP** as request type.\n3. Provide **URL** and **Name** in the input box.\n4. Click on **Create** button.\n\n![create-request](/screenshots/send-request/create-request.webp)\n\nOnce you create the new request, you can execute it by clicking the arrow button or pressing Cmd + Enter. After executing the request, the response from the server will be displayed in the Response tab.\n\n![create-new-request](/screenshots/send-request/create-new-request.webp)\n\nSelect multiple request methods\n\n\nIn Bruno, the **GET** method is set as the default HTTP method for new requests. However, you can select other HTTP methods (such as **POST**, **PUT**, **DELETE**, etc.) based on your API requirements to send data.\n\n![various-http-method](/screenshots/send-request/various-http-method.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/REST/rest-api"
  },
  "send-requests/graphql/graphql-api": {
    "name": "graphql-api",
    "content": "GraphQL request\n\n\nBruno provides the capability to send GraphQL requests, allowing you to interact with APIs that use the GraphQL query language.\n\nCreate GraphQL request\n\n\n1. Create new request inside collection.\n2. Select **GraphQL** as request type.\n3. Provide **URL** and **Name** in the input box.\n4. Click on **Create** button.\n\n![create-graphql-request](/screenshots/send-request/create-graphql-request.webp)\n\nThe default method for working with GraphQL APIs is POST, but you can adjust it based on your preferences.\n\nGraphQL request with query\n\n\nBruno provides a dedicated section called **Query** where you can write and execute all your GraphQL queries. This section is designed to make it easy for you to interact with the GraphQL API by allowing you to define the data you want to retrieve or manipulate.\n\n![query-graphql](/screenshots/send-request/graphql-req-query.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/graphql/graphql-api"
  },
  "send-requests/graphql/overview": {
    "name": "overview",
    "content": "Overview\n\n\nBruno can send requests using GraphQL, an open-source query language and runtime for APIs.\n\nGraphql request\n\n\nGraphQL APIs let clients request only the data they need through a single endpoint. It’s schema-driven, allowing clients to introspect and avoid overfetching or underfetching data. Each GraphQL request has a URL (the data endpoint) and a query (defining the data to retrieve or modify).\n\nThe API schema defines available fields, and the request may include authentication, headers, and settings as needed.\n\nGraphQL requests support three operations:\n\n- **Query**: Retrieves data, specifying fields and optional arguments for precise results.\n\n- **Mutation**: Modifies data (create, update, delete), with specified fields returned after the operation.\n\n- **Subscription**: Provides real-time updates by listening for changes to specific data fields over a persistent connection.\n",
    "parentName": "send-requests",
    "path": "send-requests/graphql/overview"
  },
  "send-requests/overview": {
    "name": "overview",
    "content": "Sending Requests and Handling Responses in Bruno\n\n\nWhether you're developing your own API or testing a third-party one, you can use Bruno as an **API Testing Client** to send requests and receive responses. With Bruno, you can create, update, delete, and send data with custom parameters and authorization details.\n\nWhen you send a request and receive a response through Bruno, the interface displays the information clearly, allowing you to debug errors, handle responses, and resolve any issues efficiently.\n\n![Home Screen](/screenshots/send-request/home-screen.webp)\n\nIn the above example we are sending `Post` request to Bruno echo server with json body. The echo server will respond with same data we sent in a request as a output.\n\nGetting Started with API Requests in Bruno\n\n\nYou can send any kind of API request using Bruno mentioned below:\n\n- [REST API](./REST/overview.mdx)\n- [GraphQL API](./graphql/overview.mdx)\n- [SOAP API](./soap/soap-request.mdx)\n\nWe are working on adding a support for gRPC, WebSocket, and MQTT you can checkout the complete [Bruno Roadmap]( here.\n",
    "parentName": "send-requests",
    "path": "send-requests/overview"
  },
  "send-requests/res-data-cookies/cookies": {
    "name": "cookies",
    "content": "Cookies\n\n\nCookies are used to store user information, session data, and provide personalized content. Bruno allows you to send, view, and delete cookies associated with your requests. After executing the request, you can easily inspect the cookies by clicking on the **Cookies** icon.\n\nSteps to view and manage cookies:\n\n\n1. **Create a request inside a collection**  \n   Ensure the request contains cookies associated with it.\n\n2. **Execute the request**  \n   Run the request to trigger the cookies.\n\n   ![execute-cookie-request](/screenshots/send-request/res-data-and-cookie/devtools/cookies/create-req-cookie.webp)\n\n3. **Click on the Cookies icon**  \n   Navigate to the **Cookies** icon on the bottom-left sidebar.\n\n   ![cookie-request](/screenshots/send-request/res-data-and-cookie/devtools/cookies/cookies.webp)\n\n4. **View and delete cookies**  \n   You can now view the cookies stored for the request and delete any as needed from the panel.\n\n   ![view-cookie-request](/screenshots/send-request/res-data-and-cookie/devtools/cookies/view-delete-cookies.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/cookies"
  },
  "send-requests/res-data-cookies/debugging/devtools": {
    "name": "devtools",
    "content": "DevTools\n\n\nBruno offers two powerful DevTools to help you inspect and troubleshoot your requests. These tools are essential for solving complex issues within Bruno.\n\n1. Chrome Console\n\n\nThe Chrome Console is commonly used by developers to inspect and troubleshoot issues. You can leverage it within Bruno to inspect requests, view parameters, and debug effectively.\n\nHow to use the Chrome Console:\n\n\n1. Open the Bruno app.\n2. Click on the **Main Menu**.\n3. Select **Chrome Console** from the dropdown menu.\n\n![chrome-console](/screenshots/send-request/res-data-and-cookie/devtools/chrome-console.webp)\n\nOnce selected, you can access the Chrome Console and inspect the requests directly within Bruno.\n\n![console-view](/screenshots/send-request/res-data-and-cookie/devtools/console-example.webp)\n\n2. Bruno DevTools\n\n\nBruno DevTools offers additional utilities tailored for API testing. These tools help with advanced debugging and troubleshooting scenarios.\n\nHow to use the Bruno DevTools:\n\n\n1. Open the Bruno app.\n2. Click on the **Main Menu**.\n3. Select **Bruno DevTools** from the dropdown menu.\n\n![console-view](/screenshots/send-request/res-data-and-cookie/devtools/bruno-devtools.webp)\n\nBruno DevTools offers variety of features such as:\n\nFeatures of Bruno DevTools:\n\n\n1. Prettify JSON\n\n\nThis feature formats and organizes your JSON data in a more readable, indented way. It helps you easily view the structure and nested elements of complex JSON responses, making it easier to debug and inspect the data.\n\n2. Convert JSON to YAML\n\n\nBruno allows you to convert JSON data into YAML format. YAML is often easier to read and work with, especially when dealing with large configurations or settings. This feature is useful for converting API responses or payloads between the two formats.\n\n3. Decode JWT\n\n\nJSON Web Tokens (JWT) are commonly used for authentication. Bruno's JWT Decoder allows you to decode and inspect the contents of a JWT, including its header, payload, and signature. This helps in debugging authentication issues by allowing you to verify the token’s data.\n\n![chrome-console](/screenshots/send-request/res-data-and-cookie/devtools/bruno-devtools-view.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/debugging/devtools"
  },
  "send-requests/res-data-cookies/debugging/timeline": {
    "name": "timeline",
    "content": "Timeline\n\n\nThe **Timeline** tab provides detailed insights into the request's response. It includes crucial information such as the body, authentication details, variables, parameters, headers, and other necessary data to inspect and validate the expected response.\n\nAdditionally, the Timeline tab displays HTTP status codes, response time, and execution details for the request.\n\nResponse Structure\n\n\nThe Timeline tab is divided into two sections:\n\n1. **Request Section (Green)**\n2. **Response Section (Purple)**\n\n![timeline-tab](/screenshots/send-request/res-data-and-cookie/devtools/timeline/timeline.webp)\n\n1. Request Section (Green)\n\n\nThe Request section provides details about the request, including:\n\n- URL\n- Query and path variables\n- Request body (data)\n- Headers\n- Authentication details\n- Other parameters sent with the request\n\n2. Response Section (Purple)\n\n\nThe Response section provides details about the response to the request, including:\n\n- Status code\n- Execution details\n- Response headers\n- Size of the response\n\nAdditionally, we have included sample data for example in the image above to demonstrate how you can view both request and response parameters in the Timeline tab.\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/debugging/timeline"
  },
  "send-requests/res-data-cookies/overview": {
    "name": "overview",
    "content": "Response Data and Cookies\n\n\nWhen an API request is executed, the server returns response data. Bruno helps you inspect, debug, and troubleshoot APIs, and even allows you to download the response data as an HTML document. Additionally, you can manage and interact with the cookies associated with the API.\n\nResponse Data\n\n\nOnce the request is executed, Bruno displays the response data from the API. You can view the following in the response panel:\n\n- Request and response headers in the timeline\n- Response body\n- Test results\n\nYou can also:\n\n- Clear the response data\n- View the request status code\n- View the API response in both web and raw formats\n\nCookies\n\n\nBruno shows the cookies associated with each request. Cookies are typically used for storing user sessions and personalized content.\n\nDebugging\n\n\nBruno includes a Chrome Console and DevTools, which are valuable tools for inspecting requests and troubleshooting issues. Some useful features in DevTools include:\n\n- JSON to YAML conversion\n- JWT decoding\n- Other features to help you work through complex issues when dealing with APIs\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/overview"
  },
  "send-requests/res-data-cookies/res-data": {
    "name": "res-data",
    "content": "Response Data\n\n\nThe API returns data as a response from the server after the request is executed. The response panel in Bruno provides you with an organized view of the API's response, including the body, headers, HTTP status code, raw response code, and more.\n\nResponse Panel\n\n\nAfter executing a request, the response panel provides detailed information on the API's response. It shows the response body, headers, status code, and other relevant data. You can also search within the response using the `cmd+f` or `ctrl+f` keyboard shortcut.\n\n![Response Panel](/screenshots/send-request/res-data-and-cookie/res-data.webp)\n\nHeaders\n\n\nThe request headers are displayed to show what was sent to the API. This can help in debugging and understanding the context of the request.\n\n![Request Headers](/screenshots/send-request/res-data-and-cookie/res-headers.webp)\n\nTimeline\n\n\nThe response timeline displays the response headers sent along with the request body, including details such as content-type, date, cache, and connection status.\n\n![Response Timeline](/screenshots/send-request/res-data-and-cookie/res-timeline.webp)\n\nSave Response\n\n\nYou can save the response data for future reference, allowing you to store the results in various formats such as HTML.\n\n![Save Response](/screenshots/send-request/res-data-and-cookie/res-save.webp)\n\nClear Response\n\n\nIf you want to reset or clear the response data, you can easily do so using the clear response option.\n\n![Clear Response](/screenshots/send-request/res-data-and-cookie/res-clear.webp)\n\nRaw Response\n\n\nThe raw response provides the unprocessed data returned by the server, giving you access to the raw output for advanced inspection.\n\n![Raw Response](/screenshots/send-request/res-data-and-cookie/res-raw.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/res-data-cookies/res-data"
  },
  "send-requests/soap/soap-request": {
    "name": "soap-request",
    "content": "SOAP API request\n\n\nBruno enables you to make HTTP calls using Simple Object Access Protocol (SOAP), a messaging protocol used for exchanging structured information between systems over a network. SOAP defines a standard for request-response communication and is based on XML data format.\n\nKey Components of a SOAP Message\n\n\n1. **Envelope**: The outermost element that defines the start and end of the message.\n2. **Header**: (Optional) Contains meta-information or additional information about the message.\n3. **Body**: The main part of the message that contains the actual data or the request/response payload\n\nCreate SOAP request\n\n\n1. Create new request inside a collection in Bruno.\n2. Select **HTTP** and add URL and name.\n3. Click on **Create** button.\n\n![create-soap-req](/screenshots/send-request/create-soap-req.webp)\n\nAdding body data\n\n\n1. After creating request, Go to **Body**.\n2. Select **XML** from the dropdown list.\n3. Add your XML data in the textarea section.\n4. Save and Execute the request.\n\nIf your request is successful, Bruno will display the response in the **Response** tab.\n\n![soap-xml-data](/screenshots/send-request/soap-xml-data.webp)\n",
    "parentName": "send-requests",
    "path": "send-requests/soap/soap-request"
  },
  "testing/automate-test/automate-test": {
    "name": "automate-test",
    "content": "import { Callout } from \"nextra/components\";\n\nRun Automated Test\n\n\nBru CLI allows you to test APIs from the command line with more control and utility.\n\n1. Create your collection inside Bruno.\n2. Open your command-line terminal and navigate to the root folder of your Bruno collection.\n3. Run the command: `bru run --reporter-html results.html`\n4. This will generate an **HTML document** with all test reports.\n5. Open the HTML document in your browser.\n\n\n  You can generate test reports in various formats, such as HTML, JUnit, and\n  JSON. In this example, we'll use HTML for demonstration.\n\n\nAfter generating the HTML report and opening it in your browser, you'll see the following dashboard:\n\n![test-web-view.webp](/screenshots/testing/test-web-view.webp)\n",
    "parentName": "testing",
    "path": "testing/automate-test/automate-test"
  },
  "testing/automate-test/manual-test": {
    "name": "manual-test",
    "content": "import PremiumBadge from \"@/components/premium-badge\";\n\nRun Manual Test\n\n\nBruno provides an easy way to run API tests from collections and generate detailed test reports. Follow these steps to run your collection, view the results, and download the test report as an HTML document.\n\nGenerate Test Report \n\n\n1. Open the **Bruno** collection\n2. Click on the **Run** option from the dropdown menu.\n\n![select-run.webp](/screenshots/testing/select-run.webp)\n\n3. Click **Run Collection** to initiate the test.\n   ![click-runner.webp](/screenshots/testing/click-runner.webp)\n\n4. Once the test run is complete, the test report will be automatically generated.\n   ![generate-test-report.webp](/screenshots/testing/generate-test-report.webp)\n\nDownload Test Report\n\n\nAfter the test report is generated, you can download it as an HTML document (`report.html`).\n\n1. Click the **Download Report** button to save the report.\n\n![details-test-reports.webp](/screenshots/testing/details-test-reports.webp)\n\nView Test Report\n\n\nOnce the report is downloaded, you can open the `report.html` file in any web browser to review the detailed test results.\n\n![test-web-view.webp](/screenshots/testing/test-web-view.webp)\n",
    "parentName": "testing",
    "path": "testing/automate-test/manual-test"
  },
  "testing/automate-test/overview": {
    "name": "overview",
    "content": "Overview\n\n\nBruno offers multiple ways to run your API tests. Testing is crucial for APIs, as a single failure can bring down the entire application. With Bruno, you can automate API tests using the [Collection Runner]( or the [Bruno CLI]( to integrate testing into your CI/CD pipeline.\n\nAutomated Testing in CI/CD\n\n\nBruno offers a command-line utility to run Collections. This allows you to integrate your tests into a CI and build process.\n\nFor more information, head to the page for [Bruno CLI](\n\n1. [Run Manual Test](./manual-test.mdx)\n2. [Run Automate Test](./automate-test.mdx)\n",
    "parentName": "testing",
    "path": "testing/automate-test/overview"
  },
  "testing/script/external-libraries": {
    "name": "external-libraries",
    "content": "import { Callout } from \"nextra/components\";\nimport { FileTree } from \"nextra/components\";\n\nExternal Libraries\n\n\nBruno allows you to load any npm module for use in your scripting workflows.\n\nPrerequisites\n\n\nBefore you begin, ensure that you have the following:\n\n1. Node.js installed on your system.\n2. Bruno installed.\n\nProject Structure\n\n\nThe folder structure for this example will be:\n\n\n  \n    \n    \n    \n    \n    \n    \n      \n    \n  \n\n\nConfiguration\n\n\nYou need to initialize `package.json` file inside your collection.\n\nNavigate to your Bruno collection directory in the terminal.\n\n```bash\ncd path/to/your/bruno-collection\n```\n\nInitialize `package.json` file inside your collection.\n\n```bash\nnpm init -y\n```\n\nNow you can install any npm package or module to use in your collection.\n\nSpectral Integration\n\n\nIn this example we're using [Spectral CLI]( as a npm package which help you to validate OpenSpec API YAML or JSON files with the built-in ruleset.\n\nYou need to have OpenAPI JSON or YAML file to work with spectral or you can download from [here]( as example.\n\nSpectral CLI Setup\n\n\nYou can install `spectral-cli` by running following command:\n\n```bash\nnpm install @stoplight/spectral-cli\n```\n\nRun this command in your terminal to initialize `.spectral.yml` file which is predefined ruleset.\n\n```js copy\necho 'extends: [\"spectral:oas\", \"spectral:asyncapi\", \"spectral:arazzo\"]' > .spectral.yaml\n```\n\nValidate your **openapi.yaml** file from Bruno collection by running following CLI command:\n\n```js copy\nspectral lint openspec.yaml --r .spectral.yaml\n```\n\nOutput Overview\n\n\nAfter following the process outlined above, warning messages will be displayed on the CLI such as duplicates and empty tags. This is how you can validate your OpenSpec files using Spectral.\n\n```bash\nopenspec.yaml:\n 2:6  warning  info-contact    Info object must have \"contact\" object.      info\n 10:9 warning  operation-tags  Operation must have non-empty \"tags\" array.  paths./pets.get\n 36:9 warning  operation-tags  Operation must have non-empty \"tags\" array.  paths./pets/{petId}.get\n```\n",
    "parentName": "testing",
    "path": "testing/script/external-libraries"
  },
  "testing/script/inbuilt-libraries": {
    "name": "inbuilt-libraries",
    "content": "import { Callout } from 'nextra/components'\n\n\nInbuilt Libraries\n\n\nBruno supports **CommonJS** syntax `require` for importing libraries. ES Modules `import/export` are not supported at this time.\n\nHere’s an example demonstrating how to use the **chai** library in Bruno:\n\n```js copy\nconst chai = require('chai');\n\nconst { expect } = chai;\n\nfunction add(a, b) {\n  return a + b;\n}\n\nconst result = add(2, 3);\n\nexpect(result).to.equal(5);\n\nconsole.log('Test passed!');\n```\nYou can include this code in the pre-request script section of Bruno to test it out.\n\nBelow is the list of inbuilt libraries supported by Bruno.\n\n- [axios]( - Promise based HTTP client for the browser and node.js\n- [atob]( -  Turn base64-encoded ascii data back to binary.\n- [btoa]( -  Turn binary data to base64-encoded ascii.\n- [chai]( -  BDD/TDD assertion library for node.js and the browser.\n- [moment]( -  Parse, validate, manipulate, and display dates and times in JavaScript.\n- [uuid]( -  For the creation of RFC4122 UUIDs.\n- [nanoid]( - A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n- [crypto-js]( - JavaScript library of crypto standards.\n\n\nTo use below inbuilt libraries in Bruno, you must be in **Developer Mode**.\n\n\n- [node-fetch]( - A light-weight module that brings Fetch API to Node.js.\n- [lodash]( -  A modern JavaScript utility library delivering modularity, performance & extras.\n- [ajv]( - Ajv JSON schema validator.\n",
    "parentName": "testing",
    "path": "testing/script/inbuilt-libraries"
  },
  "testing/script/javascript-reference": {
    "name": "javascript-reference",
    "content": "JavaScript API Reference\n\n\nHere is the complete set of API reference for the scripting feature in Bruno.\n\nRequest\n\n\nThis `req` variable is available inside your scripting and testing context.\n\nBelow is the API documentation for the methods available on `req`\n\n`getUrl`\n\n\nGet the current request url\n\n**Example:**\n\n```javascript\nlet url = req.getUrl();\n```\n\n`setUrl`\n\n\nSet the current request url\n\n**Example:**\n\n```javascript\nreq.setUrl(\"\n```\n\n`getMethod`\n\n\nGet the current request method\n\n**Example:**\n\n```javascript\nconst method = req.getMethod();\n```\n\n`setMethod`\n\n\nSet the current request method\n\n**Example:**\n\n```javascript\nreq.setMethod(\"POST\");\n```\n\n`getHeader`\n\n\nGet the request header by name\n\n**Example:**\n\n```javascript\nreq.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\n\nGet the current request headers\n\n**Example:**\n\n```javascript\nconst headers = req.getHeaders();\n```\n\n`setHeader`\n\n\nSet the request header by name\n\n**Example:**\n\n```javascript\nreq.setHeader(\"content-type\", \"application/json\");\n```\n\n`setHeaders`\n\n\nSet the current request headers\n\n**Example:**\n\n```javascript\nreq.setHeaders({\n  \"content-type\": \"application/json\",\n  \"transaction-id\": \"foobar\",\n});\n```\n\n`getBody`\n\n\nGet the current request body/payload\n\n**Example:**\n\n```javascript\nconst body = req.getBody();\n```\n\n`setBody`\n\n\nSet the request body/payload\n\n**Example:**\n\n```javascript\nreq.setBody({\n  username: \"john nash\",\n  password: \"governingdynamics\",\n});\n```\n\n`setMaxRedirects`\n\n\nSet the maximum number of redirects to follow\n\n**Example:**\n\n```javascript\nreq.setMaxRedirects(5);\n```\n\n`getTimeout`\n\n\nGets the current timeout value of the request.\n\n**Example:**\n\n```js\nconst timeout = req.getTimeout();\nconsole.log(timeout); // Logs the current timeout value\n```\n\n`setTimeout`\n\n\nSets a timeout for the request.\n\n**Example:**\n\n```js\nreq.setTimeout(5000); // Sets the timeout to 5000 milliseconds (5 seconds)\n```\n\nResponse\n\n\nThis `res` variable is available inside your scripting and testing context.\n\nBelow are the properties available on the `res` object.\n| Property | Description |\n|----------|-------------|\n| status | The response status code|\n| statusText | The response status text|\n| headers | The response headers|\n| body | The response body|\n| responseTime | The API response time|\n\nBelow are the methods available on the `res` object.\n\n`getStatus`\n\n\nGet the response status\n\n**Example:**\n\n```javascript\nlet status = res.getStatus();\n```\n\n`getHeader`\n\n\nGet the response header by name\n\n**Example:**\n\n```javascript\nlet transactionId = res.getHeader(\"transaction-id\");\n```\n\n`getHeaders`\n\n\nGet the response headers\n\n**Example:**\n\n```javascript\nlet headers = res.getHeaders();\n```\n\n`getBody`\n\n\nGet the response data\n\n**Example:**\n\n```javascript\nlet data = res.getBody();\n```\n\n`getResponseTime`\n\n\nGet the response time\n\n**Example:**\n\n```javascript\nlet responseTime = res.getResponseTime();\n```\n\nBru\n\n\nThe `bru` variable is available inside your scripting and testing context.\nIt exposes methods that allow you to interact with, e.g., process variables,\nenvironment variables and collection variables.\n\nHere is a complete table for all available methods with the `bru`.\n\n| Title                            | Description                                               |\n| -------------------------------- | --------------------------------------------------------- |\n| bru.cwd()                        | Returns the current working directory.                    |\n| bru.getEnvName()                 | Retrieves the environment name.                           |\n| bru.getProcessEnv(key)           | Fetches the process environment variable for a given key. |\n| bru.hasEnvVar(key)               | Checks if the environment variable exists.                |\n| bru.getEnvVar(key)               | Retrieves the value of an environment variable.           |\n| bru.getFolderVar(key)            | Fetches a folder-specific variable by key.                |\n| bru.getCollectionVar(key)        | Retrieves the collection-level variable for the key.      |\n| bru.setEnvVar(key, value)        | Sets a new environment variable.                          |\n| bru.deleteEnvVar(key)            | Deletes a specific environment variable.                  |\n| bru.hasVar(key)                  | Checks if a variable exists.                              |\n| bru.getVar(key)                  | Retrieves the value of a variable.                        |\n| bru.setVar(key, value)           | Sets a new variable with a key-value pair.                |\n| bru.deleteVar(key)               | Deletes a specific variable.                              |\n| bru.deleteAllVars()              | Deletes all variables.                                    |\n| bru.setNextRequest(requestName)  | Sets the next request to execute.                         |\n| req.disableParsingResponseJson() | Disables JSON response parsing for the request.           |\n| bru.getRequestVar(key)           | Retrieves the value of a request variable.                |\n| bru.runRequest(requestPathName)  | Executes a request by its path name.                      |\n| bru.getAssertionResults()        | Retrieves the results of assertions.                      |\n| bru.getTestResults()             | Fetches the test                                          |\n\nBelow is the API documentation for the methods available on `bru`\n\nHelpers\n\n\n`sleep`\n\n\nPauses execution for the specified duration. This is useful for introducing delays or waiting for a specific amount of time before proceeding with the next operation.\n\n**Example:**\n\n```javascript\nawait bru.sleep(3000);\n```\n\n`disableParsingResponseJson`\n\n\nTo prevent the automatic parsing of the JSON response body and work directly with the raw data, you can use the expression below in the pre-request script of the request.\n\n**Example:**\n\n```javascript\nbru.disableParsingResponseJson();\n```\n\nNode process environment\n\n\nBruno allows you to get Node process environment variables on the fly.\n\n`getProcessEnv`\n\n\nGet the Node process environment variable. This allows secret token usage without committing secrets to version control.\n\n**Example:**\n\n```javascript\nlet secret_token = bru.getProcessEnv(\"secret_access_token\");\n```\n\nEnvironments\n\n\nBruno allows you to get and set Bruno environment variables on the fly.\n\n`setGlobalEnvVar`\n\n\nSet the Bruno global environment variable.\n\nSyntax:\n\n```js\nbru.setGlobalEnvVar(key, value);\n```\n\n**Example:**\n\n```javascript\nbru.setGlobalEnvVar(\"val\", \"bruno\");\n```\n\n`getGlobalEnvVar`\n\n\nGet the Bruno global environment variable.\n\nSyntax:\n\n```js\nbru.getGlobalEnvVar(key);\n```\n\n**Example:**\n\n```javascript\nbru.getGlobalEnvVar(\"val\");\n```\n\n`getEnvVar`\n\n\nGet the Bruno environment variable\n\n**Example:**\n\n```javascript\nlet token = bru.getEnvVar(\"access_token\");\n```\n\n`setEnvVar`\n\n\nSet the Bruno environment variable\n\n**Example:**\n\n```javascript\nfunction onResponse(res) {\n  let data = res.getBody();\n  let token = bru.setEnvVar(\"access_token\", data.token);\n}\n```\n\nCollection Variables\n\n\nBruno allows you to get collection variables on the fly.\n\n`getCollectionVar`\n\n\nGet the collection variable\n\n**Example:**\n\n```javascript\nlet namespace = bru.getCollectionVar(\"namespace\");\n```\n\nFolder Variables\n\n\nBruno allows you to get folder variables on the fly.\n\n`getFolderVar`\n\n\nGet the folder variable\n\n**Example:**\n\n```javascript\nlet company = bru.getFolderVar(\"company\");\n```\n\nRuntime Variables\n\n\nBruno allows you to get, set and delete runtime variables on the fly.\n\n`getVar`\n\n\nGet the runtime variable\n\n**Example:**\n\n```javascript\nlet petId = bru.getVar(\"petId\");\n```\n\n`setVar`\n\n\nSet the runtime variable\n\n**Example:**\n\n```javascript\nlet data = res.getBody();\nbru.setVar(\"petId\", data.id);\n```\n\n`deleteVar`\n\n\nDelete the runtime variable\n\n**Example:**\n\n```javascript\nbru.deleteVar(\"petId\");\n```\n\nRequest Order\n\n\nYou can influence the order in which requests are being run by the request-runner (UI) or the CLI.\n\n`setNextRequest`\n\n\nBy default, the collection runner (UI) and the CLI run requests in order.\nYou can change the order by calling `setNextRequest` with the name of the next request to be run.\nThis works only in a post-request script or test-script.\n\n**Example:**\n\n```javascript\nbru.setNextRequest(\"Get process status\");\n```\n\nYou can also abort the run by explicitly setting the next request to `null`\n**Example:**\n\n```javascript\nbru.setNextRequest(null); // aborts the run gracefully\n```\n\n`runRequest`\n\n\nYou can execute any request in the collection and retrieve the response directly within the script.\n\n**Syntax:**\n\n```javascript\nconst requestResponse = await bru.runRequest(\n  \"absolute/path/to/a/request/from/collection/root\"\n);\n```\n\n**Example:**\n\n```javascript\nconst requestResponse = await bru.runRequest(\"echo/echo json\");\n```\n\nCollection Runner Utility Functions\n\n\n`setNextRequest`\n\n\nBy default, the collection runner (UI) and CLI execute requests in sequential order. You can alter this order by invoking `bru.runner.setNextRequest` with the name of the next request to execute. This function is applicable only within post-request scripts or test scripts.\n\n**Example:**\n\n```javascript\nbru.runner.setNextRequest(\"Get process status\");\n```\n\n`skipRequest`\n\n\nTo skip the execution of the current request, use `bru.runner.skipRequest()` in the pre-request script section. This function is valid only within the context of a collection run.\n\n**Example:**\n\n```javascript\nbru.runner.skipRequest();\n```\n\n`stopExecution`\n\n\nYou can terminate the collection run by using `bru.runner.stopExecution()` in the pre-request scripts, post-request scripts, or the test scripts. This function is effective only within the context of a collection run.\n\n**Example:**\n\n```javascript\nbru.runner.stopExecution();\n```\n\nTest Utility Functions\n\n\n`getTestResults`\n\n\nObtain the test results of a request by calling `bru.getTestResults` within test scripts.\n\n**Example:**\n\n```javascript\nconst testResults = await bru.getTestResults();\n```\n\n`getAssertionResults`\n\n\nObtain the assertion results of a request by calling `bru.getAssertionResults` within test scripts.\n\n**Example:**\n\n```javascript\nconst assertionResults = await bru.getAssertionResults();\n```\n",
    "parentName": "testing",
    "path": "testing/script/javascript-reference"
  },
  "testing/script/js-file": {
    "name": "js-file",
    "content": "import Image from \"next/image\";\nimport PremiumBadge from \"@/components/premium-badge\";\nimport { Callout } from \"nextra/components\";\n\nCreating a JS File in Bruno \n\n\nBruno provides the ability to create JavaScript tests where you can modularize common code and reuse the tests across different requests or collections.\n\nThis can be especially helpful in complex scripting scenarios where the same test will be run across multiple requests, or you're looking to leverage data that lays outside of Bruno.\n\nCreate a New Script\n\n\nYou can generate a JS File by:\n\n1. Right clicking on any collection or folder\n2. Select `New Script` from dropdown.\n\n![select-script](/screenshots/create-js-file/new-script.webp)\n\n3. Enter name and select **Create**\n\n![create-script](/screenshots/create-js-file/sample-js.webp)\n\nImport the Function(s)\n\n\nOnce your JS File has been created, you can now import the functions into any `Script` tab across your resources.\n\n![import-script](/screenshots/create-js-file/js-file.webp)\n\n![import-script](/screenshots/create-js-file/import-js-file.webp)\n\nHere:\n\n1. `getUserById` finds and returns a user object from the users array based on the provided id.\n2. `bru.setVar()` sets the `val` variable to the id of the fetched user.\n3. In the url `{{val}}` is replaced with value (e.g., 2), resulting in `\n\nWhen the requests are run, you will see the script being invoked.\n",
    "parentName": "testing",
    "path": "testing/script/js-file"
  },
  "testing/script/request/request-object": {
    "name": "request-object",
    "content": "Request Object\n\n\nThe `req` object represents the HTTP request made to the server. It contains various properties that define the request details.\n\n`req` Sub-Object\n\n\nThe `req` sub-object contains detailed information about the request.\n\n- `assertions` : An array containing any assertions associated with the request. *See [assertions](../../tests/assertions)*.\n- `auth` : An object containing authentication credentials, such as username and password.\n- `headers` : A sub-object representing the HTTP headers associated with the request.\n- `method` : The HTTP method used for the request (e.g., \"GET\", \"POST\").\n- `mode` : The mode of the request (e.g., \"none\", \"cors\").\n- `responseType` : The expected response type for the request (e.g., \"text\", \"json\").\n- `script` : An object containing script-related information for the request.\n- `signal` : A signal object used to abort the request.\n- `url` : The URL of the request.\n- `vars` : An object containing any variables associated with the request. *See [variables](../../script/vars)*.\n\nHeaders\n\n\nThe `headers` sub-object of the `req` object contains key-value pairs representing the HTTP headers associated with the request.\n\n```javascript\n// Example usage\nconsole.log(req.headers);\n/* Output: {\n  authorization: 'Bearer ',\n  'content-type': 'application/json',\n  accept: 'application/json',\n  // Add more headers as needed...\n} */\n```\n\nMethod\n\n\nThe `method` property of the `req` object specifies the HTTP method used for the request. Common HTTP methods include \"GET\", \"POST\", \"PUT\", \"DELETE\", etc. The method indicates the type of action the request wishes to perform on the resource. The value of the `method` property should be a string representing the desired HTTP method for the request.\n\n```javascript\n// Example usage\nconsole.log(req.method); // Output: \"GET\"\n```\n\nURL\n\n\nThe `url` property of the `req` object represents the Uniform Resource Locator (URL) of the request. It specifies the address of the resource being requested by the client. Variables enclosed within double curly braces (`{{...}}`) in the URL string are placeholders that may be replaced with actual values at runtime. These variables are not directly visible within the URL string and are typically encapsulated during request processing.\n\n```javascript\n// Example usage\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\n```\n\n\nExample Usage\n\n\n```javascript\n// Example request object\nconst req = {\n  assertions: [],\n  auth: { username: 'myUsername', password: 'mySuperPassword' },\n  headers: {\n    authorization: 'Bearer ',\n    'content-type': 'application/json',\n    accept: 'application/json',\n    // Add more headers as needed...\n  },\n  method: 'GET',\n  mode: 'none',\n  responseType: 'arraybuffer',\n  script: {\n    req: \"// Create an array of objects\\nconst data = [\\n  { i…q);\\nconst myVariable = bru.getEnvVar('password');\"\n  },\n  signal: {},\n  url: '{{base.url}}/users/2?queryTest=queryResult',\n  vars: {}\n};\n\n\n// Accessing request properties\nconsole.log(req.method); // Output: \"GET\"\nconsole.log(req.url); // Output: \"{{base.url}}/users/2?queryTest=queryResult\"\nconsole.log(req.headers.authorization); // Output: \"Bearer \"\nconsole.log(req.auth.username); // Output: \"myUsername\"\n```",
    "parentName": "testing",
    "path": "testing/script/request/request-object"
  },
  "testing/script/request/sync-requests": {
    "name": "sync-requests",
    "content": "Sync requests\n\n\nYou can make synchronous requests in your pre/post scripts. By synchronous, we mean that you can await a request in your scripting code.\n\nBelow is an inbuilt example of using `axios` library to\n```js\nconst axios = require(\"axios\");\n\nconst response = await axios.get(\"\n\nbru.setVar(\"avatarUrl\", response.data.avatar_url);\n```\n\n**Example:**\n![sync requests](/screenshots/sync-requests.webp)\n\n",
    "parentName": "testing",
    "path": "testing/script/request/sync-requests"
  },
  "testing/script/response/response-object": {
    "name": "response-object",
    "content": "Response Object\n\n\nThe `res` object that is available inside the [vars](../vars), [assertions](../../tests/assertions), [scripting](../getting-started) and [testing](../../tests/introduction)\ncontexts can be used to extract values from the response body, headers and status.\n\n*Note that the `res` object is only available in the context of a request.*\n\nYou can also access it with [response queries](./response-query).\n\nObject Structure\n\n\nThe `res` object has the following properties:\n\n- `body`: Represents the response body containing data returned to the client.\n- `headers`: Contains key-value pairs representing HTTP headers associated with the response.\n- `status`: Represents the HTTP status code indicating the outcome of the request.\n\nProperty Descriptions\n\n\n`body`\n\n\nThe `body` property of the `res` object contains the response data sent to the client. It can be a string, an object, or a stream, depending on the application's needs.\n\n`headers`\n\n\nThe `headers` property contains HTTP headers associated with the response. These headers provide metadata about the response, such as content type, encoding, and caching directives.\n\n`status`\n\n\nThe `status` property represents the HTTP status code of the response. It indicates the outcome of the request, such as success, redirection, client error, or server error.\n\nExample Usage\n\n\n```javascript\n// Example response object\nconst res = {\n  body: '{\"message\": \"Hello, world!\"}',\n  headers: {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'no-cache',\n  },\n  status: 200,\n};\n\n// Accessing response properties\nconsole.log(res.body); // Output: '{\"message\": \"Hello, world!\"}'\nconsole.log(res.headers['Content-Type']); // Output: 'application/json'\nconsole.log(res.status); // Output: 200\n```\n\n\n\n\n\n\n\n",
    "parentName": "testing",
    "path": "testing/script/response/response-object"
  },
  "testing/script/response/response-query": {
    "name": "response-query",
    "content": "Response Query\n\n\nThe `res` object that is available inside the [vars](../vars), [assertions](../../tests/assertions), [scripting](../getting-started) and [testing](../../tests/introduction) contexts can be queried for data by invoking it like below.\n\nThink of it as `lodash.get()` on steroids\n\n```javascript\nres('order.total')\n```\n\nExamples\n\n```javascript\nconst data = {\n  customer: {\n    address: {\n      city: \"bangalore\"\n    },\n    orders: [\n      {\n        id: \"order-1\",\n        items: [\n          { id: 1, amount: 10 },\n          { id: 2, amount: 20 }\n        ]\n      },\n      {\n        id: \"order-2\",\n        items: [\n          { id: 3, amount: 30 },\n          { id: 4, amount: 40 }\n        ]\n      }\n    ]\n  },\n};\n```\n| Query                                   | Output                             |\n|-----------------------------------------|------------------------------------|\n| res(\"customer.address.city\")            | bangalore                          |\n| res(\"customer.orders.items.amount\")     | [10, 20, 30, 40]                   |\n| res(\"customer.orders.items.amount[0]\") | 10                                 |\n| res(\"..items.amount\")                   | [10, 20, 30, 40]                   | |\n| res(\"..amount\")                         | [10, 20, 30, 40]                   |\n| res(\"..items.amount[0]\")                | 10                                 |\n| res(\"..items[0].amount\")                | 10                                 |\n| res(\"..items[5].amount\")                | undefined                          |\n| res(\"..id\")                             | [\"order-1\", 1, 2, \"order-2\", 3, 4] |\n| res(\"customer.orders.foo\")              | undefined                          |\n| res(\"..customer.foo\")                   | undefined                          |\n| res(\"..address\")                        | [\\{ city: \"bangalore\" \\}]          |\n| res(\"..address[0]\")                     | \\{ city: \"bangalore\" \\}            |\n\nAPI\n\n\nStandard dot notation\n\n\n**Example:**\n```javascript\nres('customer.orders.items.amount')\n```\n\nDeep navigation .. double dots\n\n\n**Example:**\n```javascript\nres('..items.amount')\n```\n\nArray indexing\n\n\n**Example:**\n```javascript\nres('..items[0].amount')\n```\n\nArray filtering [?] with corresponding filter function\n\n\n**Example:**\n```javascript\nres('..items[?].amount', i => i.amount > 20)\n```\n\n\nArray mapping [?] with corresponding mapper function\n\n\n**Example:**\n```javascript\nres('..items..amount[?]', amt => amt + 10)\n```\n\n\n\n\n\n\n\n\n",
    "parentName": "testing",
    "path": "testing/script/response/response-query"
  },
  "testing/script/script-flow": {
    "name": "script-flow",
    "content": "import { Callout } from 'nextra/components'\n \nScript Flow in Bruno\n\n\nIn Bruno, we provide two types of script flows: **Sandwich** and **Sequential (Natural)**. These flows control the order in which the scripts at various levels of your API test collections are executed, allowing for flexibility and control over your automation.\n\nFlow Types\n\n\n1. Sandwich Flow\n2. Sequential (Natural) Flow\n\n1. Sandwich Flow\n\n\nIn the **Sandwich Flow**, scripts are executed in the following order:\n\n- **Collection Pre Script**\n  - **Folder Pre Script**\n    - **Request Pre Script**\n- **Request Post Script**\n  - **Folder Post Script**\n    - **Collection Post Script**\n\nThis order allows you to execute actions at multiple levels (collection, folder, and request) before and after each test. It is useful when you need to configure different environments or states before and after running tests at various levels.\n\n2. Sequential (Natural) Flow\n\n\nIn the **Sequential Flow**, scripts are executed in this order:\n\n- **Collection Pre Script**\n  - **Folder Pre Script**\n    - **Request Pre Script**\n- **Collection Post Script**\n  - **Folder Post Script**\n    - **Request Post Script**\n\nThis flow executes scripts in a more natural, linear order. After the **Request Pre Script**, it runs the **Collection Post Script**, followed by **Folder Post Script**, and finally, the **Request Post Script**. This flow may be better suited when you want a clean execution from top to bottom.\n\nCode Example\n\n\n\n  If the `flow` property is not specified, Sandwich is used by default.\n\n\nYou can set the flow type (either `sandwich` or `sequential`) in your `bruno.json` configuration file:\n\n```json showLineNumbers filename=\"bruno.json\" {7}\n{\n  \"scripts\": {\n    \"moduleWhitelist\": [\"crypto\", \"buffer\", \"form-data\"],\n    \"filesystemAccess\": {\n      \"allow\": true\n    },\n    \"flow\": \"sequential\" // Or \"sandwich\"\n  }\n}\n```\n",
    "parentName": "testing",
    "path": "testing/script/script-flow"
  },
  "testing/script/vars": {
    "name": "vars",
    "content": "Vars\n\n\nVars allow you to set variables before request, and after you receive the response.\n\nVars are scoped within the request and cannot be accessed outside of it.\n\n> Note: Prior to v1.20.0, request vars were accessible at the collection scope, but this is no longer the case.\n\nIn the *Pre Request Variables* section, you can write any Strings, Numbers or any valid JavaScript literal.\n\nIn the *Post Response Variables* section, you can write any valid JavaScript expression. The res object is available, allowing you to declaratively parse the [response](./javascript-reference#response) and set variables, instead of writing scripts to do the same.\n\nFor parsing the response, you can checkout the [response query](./response/response-query) that allows you to easily query your response.\n\n**Example:**\n![bru vars](/screenshots/vars.webp)\n\n![Screenshot showing how to use defined variables in the request body](/screenshots/set-vars.webp)\n",
    "parentName": "testing",
    "path": "testing/script/vars"
  },
  "testing/script/whitelisting-modules": {
    "name": "whitelisting-modules",
    "content": "import { Callout } from \"nextra/components\";\n\nWhitelisting Modules\n\n\nThe scripts can use both [external libraries](external-libraries) (via package.json and npm install) and certain [built-in](inbuilt-libraries) modules in Node.js (like fs, path, etc.). However, for security reasons, not all built-in Node.js modules are made accessible by default in Bruno scripts.\n\nWhy Whitelisting\n\n\nBruno requires you to explicitly enable (whitelist) modules before they can be used in scripts due to security reasons. The whitelisting process ensures that only the modules you specifically choose to enable will be available to your scripts.\n\nYou can manually enable or whitelist these modules by editing your `bruno.json` file. Make sure to add the `script` section to the file.\n\n```json copy filename=\"bruno.json\" showLineNumbers {6-11}\n{\n  \"version\": \"1\",\n  \"name\": \"collection_name\",\n  \"type\": \"collection\",\n  \"ignore\": [\"node_modules\", \".git\"],\n  \"scripts\": {\n    \"moduleWhitelist\": [\"child_process\"],\n    \"filesystemAccess\": {\n      \"allow\": true\n    }\n  }\n}\n```\n\n\n  filesystemAccess is required for reading and writing files, especially for\n  modules that depend on it.\n\n\nWhitelisting Multiple Modules\n\n\nIf you need to use multiple built-in or trusted third-party modules in your Bruno script, you can whitelist them by adding them to the `moduleWhitelist` array. For example:\n\n```json copy filename=\"bruno.json\" showLineNumbers\n \"scripts\": {\n      \"moduleWhitelist\": [\"crypto\", \"jwt\", \"child_process\"],\n      \"filesystemAccess\": {\n        \"allow\": true\n      }\n    }\n```\n\nOnly whitelist modules that you trust and that are necessary for your script to function properly.\n",
    "parentName": "testing",
    "path": "testing/script/whitelisting-modules"
  },
  "testing/tests/assertions": {
    "name": "assertions",
    "content": "Assertions\n\n\nAssertions allow you to declaratively write tests.\n\nThis should cover most of your testing needs. For complex tests, you can write test scripts.\n\nGetting Started with Assertions\n\n\nTo get started with basic tests using assertions, follow these steps:\n\n1.  **Open a Collection**: Navigate to the Collection containing the request you want to test.\n2.  **Select a Request**: Click on a request within the Collection.\n3.  **Go to the Assertions Tab**: Click on the Assertions tab to access the testing interface.\n4.  **Write Your Test**: You can now specify an **expression**, an **operator**, and the **value** to test against the API response.\n\n![bru assertions](/screenshots/get-started/bruno-basics/create_test/bru_test_assert.webp)\n\nThis method allows you to quickly test different conditions and verify that the API returns the expected results.\n\nExample:\n\n\n- **Expression**: Verify the body response status (e.g., response.body.status).\n- **Operator**: Choose the operator (e.g., equals, contains).\n- **Value**: Provide the expected value (e.g., 200).\n\nBruno will then automatically run the test and give you the results, letting you know if the assertion passes or fails.\n",
    "parentName": "testing",
    "path": "testing/tests/assertions"
  },
  "testing/tests/data-driven-testing": {
    "name": "data-driven-testing",
    "content": "import Video from \"../../../components/Video\";\n\nIterate Using Data Files\n\n\nThe **Collection Runner** feature allows you to iterate over data files, making it easy to automate and manage data-driven requests. Bruno supports both CSV and JSON files for running requests, so you can efficiently run tests or process multiple data inputs.\n\nIntroduction\n\n\nIn this tutorial, we'll explore the Collection Runner feature, which enables you to run collections using custom data for each iteration.\n\nSteps to Get Started\n\n\n1. **Open the Bruno app.**\n2. **Create a collection** called `runner-example`\n3. **Create a POST request** and name it `runner-request`\n4. **Use the URL**: `\n5. **Select the JSON format for the request body** and add the following data:\n\n```bash\n{\n    \"name\": \"morpheus\",\n    \"job\": \"leader\"\n}\n```\n\n> Selecting the JSON option for the request body and adding JSON data is optional.\n\nUsing the Collection Runner\n\n\nWe will create a sample data file `csv-example.csv` that includes input fields such as `name` and `job` to be used in data-driven testing. You need to create a CSV or JSON file according to the specific requirements of the API you're working with.\n\nSince the API in this case expects two data inputs `name` and `job` the file should contain these fields. Here's an example of how to structure your data:\n\n**1. CSV Format Example**  \nA sample CSV file might look like this:\n\n```bash copy\nname, job\nJohn Doe, Software Engineer\nJane Smith, Product Manager\nMark Lee, Data Scientist\n```\n\n**2. JSON Format Example**  \nA sample JSON file might look like this:\n\n```bash copy\n[\n  { \"name\": \"John Doe\", \"job\": \"Software Engineer\" },\n  { \"name\": \"Jane Smith\", \"job\": \"Product Manager\" },\n  { \"name\": \"Mark Lee\", \"job\": \"Data Scientist\" }\n]\n```\n\nNow you're ready to use the Collection Runner. You can access it in two ways:\n\nUsing the Bruno App\n\n\n1. Click on the runner icon in the right-hand navbar.\n2. Check the **Run with Parameters** option.\n3. Select the file type: CSV or JSON.\n4. Click **Run Collection**.\n\nOnce the execution is complete, you can review the results for each individual request and check their statuses.\n\n\n\nHow to Use Variables from CSV/JSON Files\n\n\nWhen you upload a CSV or JSON file, the variables within the file can be accessed using the `{{var}}` syntax.\nYou can access these variables dynamically in your requests and use them within Bruno.\n\n**Example**:\n\nAccessing Variables in Request Body\n\n\n```json showLineNumbers filename=\"request-body\"\n{\n  \"name\": \"{{name}}\",\n  \"email\": \"{{email}}\"\n}\n```\n\nIn this example, `{{name}}` and `{{email}}` will be replaced by the actual values from the uploaded JSON file.\n\n```json showLineNumbers filename=\"request-with-interpolated-values\"\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john.doe@example.com\"\n}\n```\n\nAccessing Variables in Scripts\n\n\nYou can also access these variables directly in your pre-request or post-response scripts using `bru.getVar()`.\n\n```js\nconsole.log(bru.getVar(\"name\")); // Outputs: John Doe\nconsole.log(bru.getVar(\"email\")); // Outputs: john.doe@example.com\n```\n\nWhen you run the request, you’ll see the output of these variables in the console.\n\nUsing the Bruno CLI\n\n\n1. Navigate to the root directory of your Bruno collection.\n2. Run the following command:\n\n```bash copy\n   bru run --reporter-html results.html --csv-file-path /path/to/csv/file.csv\n```\n\nor\n\n```bash copy\n   bru run --output results.html --format html --csv-file-path /path/to/csv/file.csv\n```\n\n\n\nIt will create a `results.html` file in your Bruno collection's root directory. You can view this file in your browser.\n\nCommand Overview\n\n\n1. `--reporter-html results.html`: Generates a human-readable HTML report.\n2. `--csv-file-path /path/to/csv/file.csv`: Specifies the path to the CSV file you want to use.\n\n[Bruno CLI Overview](../../bru-cli/overview)\n",
    "parentName": "testing",
    "path": "testing/tests/data-driven-testing"
  },
  "testing/tests/introduction": {
    "name": "introduction",
    "content": "import { Callout } from \"nextra/components\";\n\nTesting\n\n\n\n  Bruno uses the [Chai library]( so you can follow the\n  same syntax for writing assertions in your tests.\n\n\nBruno supports writing automation test scripts in JavaScript for your API requests to assert its behaviour.\n\nSome of the benefits include\n\n- Increased efficiency: The tests can be run repeatedly, reducing the time and effort required for manual testing.\n- Increased coverage: Automated tests can cover a larger range of scenarios and edge cases compared to manual testing.\n- Continuous integration/continuous delivery (CI/CD): Automated API tests can be integrated into a CI/CD pipeline, ensuring that API changes are thoroughly tested before deployment.\n- Easier maintenance: Automated tests can be easily updated as the API evolves, reducing the maintenance burden compared to manual tests.\n- Easier regression testing: Automated tests can be easily repeated after changes are made to the API, reducing the time required for regression testing.\n\n**Example:**\n\n```javascript\ntest(\"should be able to login\", function () {\n  const data = res.getBody();\n  expect(res.getStatus()).to.equal(200);\n});\n\ntest(\"should return json\", function () {\n  const data = res.getBody();\n  expect(res.getBody()).to.eql({\n    hello: \"Bruno\",\n  });\n});\n```\n\n**Screenshot:**\n\n![bru lang sample](/screenshots/test-script.webp)\n\nScripting API\n\n\nPlease see the [Scripting API](../script/javascript-reference) for a comprehensive set of methods that enable you to write custom JavaScript code to automate and test your API requests in Bruno. It allows you to manipulate request variables, modify headers, handle response data, and implement complex logic directly within your test scripts.\n",
    "parentName": "testing",
    "path": "testing/tests/introduction"
  }
}